{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Summary","text":""},{"location":"#concept","title":"Concept","text":"<p>The <code>Report</code> Model from citation-report is only one part of a Philippine Supreme Court citation. This library will handle the patterns involved with respect to the Docket.</p> <p>Let's look at sample citation that is typically found in the body and the footnotes section of a decision:</p> <p>Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449</p> <p>We can separate the Docket portion from the <code>Report</code> portion:</p> Docket Report G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000 342 SCRA 449 <p>For lack of a better term, we'll call the combination of a Docket and a <code>Report</code> a Docket Report Citation.</p>"},{"location":"#utility","title":"Utility","text":"<p>Both citation-reports and citation-docket are dependencies of citation-utils.</p> <p>Like citation-reports, there is a problem involving inconsistent use of values. We address it the same way by dissecting the component parts and generating a uniform citation.</p>"},{"location":"api-build/","title":"Build API","text":""},{"location":"api-build/#docket-model","title":"Docket Model","text":"<p>         Bases: <code>BaseModel</code></p> <p>The Docket is the modern identifier of a Supreme Court decision.</p> <p>It is based on a category, a serial id, and a date.</p> Field Type Description <code>context</code> optional (str) Full texted matched by the regex pattern <code>short_category</code> optional (str) See short-docket-category-model <code>category</code> optional (str) See docket-category-model <code>ids</code> optional (str) The serial number of the docket category <code>docket_date</code> optional (date) The date associated with the docket <p>It's important that each field be optional. The <code>Docket</code> will be joined to another <code>BaseModel</code> object, i.e. the <code>Report</code>, from a third-party library.</p> Sample Citation Category Serial Date G.R. Nos. 138570, October 10, 2000 GR 74910 October 10, 2000 A.M. RTJ-12-2317 (Formerly OCA I.P.I. No. 10-3378-RTJ), Jan 1, 2000 AM RTJ-12-2317 Jan 1, 2000 A.C. No. 10179 (Formerly CBD 11-2985), March 04, 2014 AC 10179 Mar. 4, 2014 <p>It is often paired with a Report, which is the traditional identifier based on volume and page numbers.</p> Source code in <code>citation_docket/regexes/models/docket_model.py</code> Python<pre><code>class Docket(BaseModel):\n\"\"\"\n    The Docket is the modern identifier of a Supreme Court decision.\n    It is based on a category, a serial id, and a date.\n    Field | Type | Description\n    --:|:--:|:--\n    `context` | optional (str) | Full texted matched by the regex pattern\n    `short_category` | optional (str) | See [short-docket-category-model][]\n    `category` | optional (str) | See [docket-category-model][]\n    `ids` | optional (str) | The serial number of the docket category\n    `docket_date` | optional (date) | The date associated with the docket\n    It's important that each field be **optional**. The `Docket` will be joined\n    to another `BaseModel` object, i.e. the `Report`, from a third-party library.\n    Sample Citation | Category | Serial | Date\n    :-- |:--:|:--:|:--:\n    _G.R. Nos. 138570, October 10, 2000_ | GR | 74910 | October 10, 2000\n    _A.M. RTJ-12-2317 (Formerly OCA I.P.I. No. 10-3378-RTJ), Jan 1, 2000_ | AM | RTJ-12-2317 |Jan 1, 2000\n    _A.C. No. 10179 (Formerly CBD 11-2985), March 04, 2014_ | AC | 10179 | Mar. 4, 2014\n    It is often paired with a Report, which is the traditional\n    identifier based on volume and page numbers.\n    \"\"\"  # noqa: E501\ncontext: str = Field(\n...,\ntitle=\"Context\",\ndescription=\"Full texted matched by the regex pattern.\",\n)\nshort_category: str = Field(\n...,\ntitle=\"Docket Acronym\",\ndescription=\"GR, AM, AC, BM, etc.\",\nmin_length=2,\nmax_length=3,\n)\ncategory: str = Field(\n...,\ntitle=\"Docket Category\",\ndescription=(\n\"e.g. General Register, Administrative Matter,\"\n\" Administrative Case, Bar Matter\"\n),\n)\nids: str = Field(\n...,\ntitle=\"Raw Docket IDs\",\ndescription=(\n\"The docket can contain multiple tokens, e.g. 24141, 14234, 2342.\"\n),\n)\ndocket_date: date = Field(\n...,\ntitle=\"Docket Date\",\ndescription=\"Either in UK, US styles\",\n)\ndef __str__(self) -&gt; str:\nif self.serial_text:\nreturn (\nf\"{self.short_category} {self.serial_text},\"\nf\" {self.formatted_date}\"\n)\nreturn \"No proper string detected.\"\n@property\ndef serial_text(self) -&gt; str:\n\"\"\"From the raw `ids`, get the `cleaned_ids`, and of these `cleaned_ids`,\n            extract the `@first_id` found to deal with compound ids, e.g.\n            ids separated by 'and' and ','\n        Returns:\n            str: Singular text identifier\n        \"\"\"\nif x := self.first_id or self.ids:\nif adjust := gr_prefix_clean(x):\nreturn adjust\nreturn x\n@property\ndef first_id(self):\n\"\"\"Get the first element from a list of separators when possible.\"\"\"\ndef first_exists(char, text):\nreturn text.split(char)[0] if char in text else None\nfor char in [\",\", \";\", \" and \", \" AND \", \"&amp;\"]:\nif res := first_exists(char, self.ids):\nreturn res\nreturn self.ids\n@property\ndef formatted_date(self):\nif self.docket_date:\nreturn self.docket_date.strftime(DOCKET_DATE_FORMAT)\nreturn None\n</code></pre>"},{"location":"api-build/#citation_docket.Docket-attributes","title":"Attributes","text":""},{"location":"api-build/#citation_docket.regexes.models.docket_model.Docket.first_id","title":"<code>first_id</code>  <code>property</code>","text":"<p>Get the first element from a list of separators when possible.</p>"},{"location":"api-build/#citation_docket.regexes.models.docket_model.Docket.serial_text","title":"<code>serial_text: str</code>  <code>property</code>","text":"<p>From the raw <code>ids</code>, get the <code>cleaned_ids</code>, and of these <code>cleaned_ids</code>,     extract the <code>@first_id</code> found to deal with compound ids, e.g.     ids separated by 'and' and ','</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Singular text identifier</p>"},{"location":"api-build/#docket-category","title":"Docket Category","text":""},{"location":"api-build/#docket-category-model","title":"Docket Category Model","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>There are four common docket references involving Philippine Supreme Court decisions.</p> Name Value <code>GR</code> General Register <code>AM</code> Administrative Matter <code>AC</code> Administrative Case <code>BM</code> Bar Matter <p>Complication: These categories do not always represent decisions. For instance, there are are <code>AM</code> and <code>BM</code> docket numbers that represent rules rather than decisions.</p> Source code in <code>citation_docket/regexes/models/docket_category.py</code> Python<pre><code>class DocketCategory(str, Enum):\n\"\"\"There are four common docket references involving Philippine Supreme Court\n    decisions.\n    Name | Value\n    :--|:--\n    `GR` | General Register\n    `AM` | Administrative Matter\n    `AC` | Administrative Case\n    `BM` | Bar Matter\n    Complication: These categories do not always represent decisions. For instance,\n    there are are `AM` and `BM` docket numbers that represent rules rather\n    than decisions.\n    \"\"\"\nGR = \"General Register\"\nAM = \"Administrative Matter\"\nAC = \"Administrative Case\"\nBM = \"Bar Matter\"\n</code></pre>"},{"location":"api-build/#short-docket-category-model","title":"Short Docket Category Model","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>For purposes of creating an enumeration for use in <code>sqlpyd</code> wherein the value will be stored in the database.</p> Name Value <code>GR</code> GR <code>AM</code> AM <code>AC</code> AC <code>BM</code> BM Source code in <code>citation_docket/regexes/models/docket_category.py</code> Python<pre><code>class ShortDocketCategory(str, Enum):\n\"\"\"For purposes of creating an enumeration for use in `sqlpyd` wherein\n    the value will be stored in the database.\n    Name | Value\n    :--|:--\n    `GR` | GR\n    `AM` | AM\n    `AC` | AC\n    `BM` | BM\n    \"\"\"\nGR = DocketCategory.GR.name\nAM = DocketCategory.AM.name\nAC = DocketCategory.AC.name\nBM = DocketCategory.BM.name\n</code></pre>"},{"location":"api-build/#docket-constructor","title":"Docket Constructor","text":"<p>Although the different category docket models share a similar configuration, the regex strings involved are different for each, prompting the need for a preparatory constructor class:</p> <p>         Bases: <code>BaseModel</code></p> <p>Prefatorily, regex strings are defined so that a <code>re.Pattern</code> object can take advantage of the \"group_name\" assigned in the string.</p> <p>These are the docket styles with regex strings predefined:</p> <ol> <li>General Register</li> <li>Administrative Matter</li> <li>Administrative Case</li> <li>Bar Matter</li> </ol> <p>The Constructor formalizes the assigned group names into their respective fields.</p> <p>Relatedly, it takes advantage of the <code>citation_date</code> and the <code>citation_report</code> libraries in generating the main <code>@pattern</code> since the regex strings above are only concerned with the <code>key</code> <code>num</code> <code>id</code> formula part of the docket, e.g. <code>GR</code> <code>No.</code> <code>123</code>... but not the accompanying date and report.</p> Source code in <code>citation_docket/regexes/models/constructor.py</code> Python<pre><code>class Constructor(BaseModel):\n\"\"\"Prefatorily, regex strings are defined so that a\n    `re.Pattern` object can take advantage of the \"group_name\"\n    assigned in the string.\n    These are the docket styles with regex strings predefined:\n    1. General Register\n    2. Administrative Matter\n    3. Administrative Case\n    4. Bar Matter\n    The Constructor formalizes the assigned group names into\n    their respective fields.\n    Relatedly, it takes advantage of\n    the `citation_date` and the `citation_report` libraries in\n    generating the main `@pattern` since the regex strings above\n    are only concerned with the `key` `num` `id` formula part\n    of the docket, e.g. `GR` `No.` `123`... but not the accompanying\n    date and report.\n    \"\"\"\nlabel: str = Field(\n...,\ntitle=\"Docket Label\",\ndescription=\"e.g. General Register, Administrative Matter\",\n)\nshort_category: str = Field(\n...,\ntitle=\"Docket Category Shorthand\",\ndescription=\"e.g. GR, AM\",\n)\ngroup_name: str = Field(\n...,\ntitle=\"Regex Group Name\",\ndescription=(\n\"e.g. 'gr_test_phrase' identifies that portion of the\"\n\"Match object that should be associated with the label.\"\n),\n)\ninit_name: str = Field(\n...,\ntitle=\"Regex Initial Group Name\",\ndescription=\"e.g. gr_mid, am_init; see .regexes for other group names\",\n)\ndocket_regex: str = Field(\n...,\ntitle=\"Regex Expression Proper\",\ndescription=(\n\"The full regex expression which includes the group\"\n\"names referred to above.\"\n),\n)\nkey_regex: str = Field(\n...,\ntitle=\"Regex Key\",\ndescription=\"Regex portion to get the serial ids\",\n)\nnum_regex: str = Field(\n...,\ntitle=\"Regex Num\",\ndescription=\"Regex portion for the num keyword to get the serial ids\",\n)\n@property\ndef pattern(self) -&gt; re.Pattern:\n\"\"\"Construct the regex string and generate a full Pattern object from:\n        1. `docket_regex`,\n        2. `docket_date` defined in the citation-date library\n        3. an optional `REPORT_REGEX` defined in the citation-report library\n        Returns:\n            Pattern: Combination of Docket and Report styles.\n        \"\"\"\nreturn re.compile(\n\"\".join(\n[\nrf\"{self.docket_regex}\",\nrf\"(?P&lt;extra_phrase&gt;{formerly}?{pp}?){docket_date}\",\nrf\"(?P&lt;opt_report&gt;\\,\\s*{REPORT_REGEX})?\",\n]\n),\nre.I | re.X,\n)\n@property\ndef key_num_pattern(self) -&gt; re.Pattern:\n\"\"\"Unlike the full @pattern, this regex compiled object is limited to\n        just the key and number elements, e.g. \"GR No. 123\" or \"BP Blg. 45\"\n        \"\"\"\nregex = rf\"{self.key_regex}({self.num_regex})?\"\nreturn re.compile(regex, re.I | re.X)\ndef detect(self, raw: str) -&gt; Iterator[dict[str, Any]]:\n\"\"\"Logic: if the `self.init_name` Match group exists, get the entire\n        regex expression represented by `self.group_name`, then extract\n        subgroups which will consist of Docket and Report parts.\n        Args:\n            raw (str): _description_\n        Yields:\n            Iterator[dict[str, Any]]: A dict that can fill up a\n                Docket + Report pydantic BaseModel\n        \"\"\"\nfor match in self.pattern.finditer(raw):\nif match.group(self.init_name):\nif ctx := match.group(self.group_name).strip(\", \"):\nraw_id = cull_extra(self.key_num_pattern.sub(\"\", ctx))\nids = raw_id.strip(\"()[] .,;\")\nraw_date = match.group(\"docket_date\")\ndate_found = decode_date(raw_date, True)\nif ids and date_found:\nyield dict(\ncontext=ctx,\nshort_category=self.short_category,\ncategory=self.label,\nids=ids,\ndocket_date=date_found,\npublisher=get_publisher_label(match),\nvolpubpage=match.group(\"volpubpage\"),\nvolume=match.group(\"volume\"),\npage=match.group(\"page\"),\n)\n</code></pre>"},{"location":"api-build/#citation_docket.regexes.models.constructor.Constructor-attributes","title":"Attributes","text":""},{"location":"api-build/#citation_docket.regexes.models.constructor.Constructor.key_num_pattern","title":"<code>key_num_pattern: re.Pattern</code>  <code>property</code>","text":"<p>Unlike the full @pattern, this regex compiled object is limited to just the key and number elements, e.g. \"GR No. 123\" or \"BP Blg. 45\"</p>"},{"location":"api-build/#citation_docket.regexes.models.constructor.Constructor.pattern","title":"<code>pattern: re.Pattern</code>  <code>property</code>","text":"<p>Construct the regex string and generate a full Pattern object from:</p> <ol> <li><code>docket_regex</code>,</li> <li><code>docket_date</code> defined in the citation-date library</li> <li>an optional <code>REPORT_REGEX</code> defined in the citation-report library</li> </ol> <p>Returns:</p> Name Type Description <code>Pattern</code> <code>re.Pattern</code> <p>Combination of Docket and Report styles.</p>"},{"location":"api-build/#citation_docket.regexes.models.constructor.Constructor-functions","title":"Functions","text":""},{"location":"api-build/#citation_docket.regexes.models.constructor.Constructor.detect","title":"<code>detect(raw)</code>","text":"<p>Logic: if the <code>self.init_name</code> Match group exists, get the entire regex expression represented by <code>self.group_name</code>, then extract subgroups which will consist of Docket and Report parts.</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>str</code> <p>description</p> required <p>Yields:</p> Type Description <code>Iterator[dict[str, Any]]</code> <p>Iterator[dict[str, Any]]: A dict that can fill up a Docket + Report pydantic BaseModel</p> Source code in <code>citation_docket/regexes/models/constructor.py</code> Python<pre><code>def detect(self, raw: str) -&gt; Iterator[dict[str, Any]]:\n\"\"\"Logic: if the `self.init_name` Match group exists, get the entire\n    regex expression represented by `self.group_name`, then extract\n    subgroups which will consist of Docket and Report parts.\n    Args:\n        raw (str): _description_\n    Yields:\n        Iterator[dict[str, Any]]: A dict that can fill up a\n            Docket + Report pydantic BaseModel\n    \"\"\"\nfor match in self.pattern.finditer(raw):\nif match.group(self.init_name):\nif ctx := match.group(self.group_name).strip(\", \"):\nraw_id = cull_extra(self.key_num_pattern.sub(\"\", ctx))\nids = raw_id.strip(\"()[] .,;\")\nraw_date = match.group(\"docket_date\")\ndate_found = decode_date(raw_date, True)\nif ids and date_found:\nyield dict(\ncontext=ctx,\nshort_category=self.short_category,\ncategory=self.label,\nids=ids,\ndocket_date=date_found,\npublisher=get_publisher_label(match),\nvolpubpage=match.group(\"volpubpage\"),\nvolume=match.group(\"volume\"),\npage=match.group(\"page\"),\n)\n</code></pre>"},{"location":"api-extraction/","title":"Extraction API","text":""},{"location":"api-extraction/#extract_dockets","title":"extract_dockets()","text":"<p>Extract from <code>raw</code> text all raw citations which should include their <code>Docket</code> and <code>Report</code> component parts.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from citation_docket import extract_dockets\n&gt;&gt;&gt; text = \"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"\n&gt;&gt;&gt; docket = next(extract_dockets(text))\nCitationGeneralRegister(publisher='SCRA', volume='342', page='449', volpubpage='342 SCRA 449', report_date=None, context='G.R. Nos. 138570, 138572, 138587, 138680, 138698', short_category='GR', category='General Register', ids='138570, 138572, 138587, 138680, 138698', docket_date=datetime.date(2000, 10, 10))\n&gt;&gt;&gt; str(docket)\n'GR 138570, Oct. 10, 2000'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>str</code> <p>Text to look for <code>Dockets</code> and <code>Reports</code></p> required <p>Yields:</p> Type Description <code>Iterator[DocketReportCitationType]</code> <p>Iterator[DocketReportCitationType]: Any of custom <code>Docket</code> with <code>Report</code> types, e.g. <code>CitationAdministrativeCase</code>, etc.</p> Source code in <code>citation_docket/__main__.py</code> Python<pre><code>def extract_dockets(\nraw: str,\n) -&gt; Iterator[DocketReportCitationType]:\n\"\"\"Extract from `raw` text all raw citations which\n    should include their `Docket` and `Report` component parts.\n    Examples:\n        &gt;&gt;&gt; from citation_docket import extract_dockets\n        &gt;&gt;&gt; text = \"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"\n        &gt;&gt;&gt; docket = next(extract_dockets(text))\n        CitationGeneralRegister(publisher='SCRA', volume='342', page='449', volpubpage='342 SCRA 449', report_date=None, context='G.R. Nos. 138570, 138572, 138587, 138680, 138698', short_category='GR', category='General Register', ids='138570, 138572, 138587, 138680, 138698', docket_date=datetime.date(2000, 10, 10))\n        &gt;&gt;&gt; str(docket)\n        'GR 138570, Oct. 10, 2000'\n    Args:\n        raw (str): Text to look for `Dockets` and `Reports`\n    Yields:\n        Iterator[DocketReportCitationType]: Any of custom `Docket` with `Report` types, e.g. `CitationAdministrativeCase`, etc.\n    \"\"\"  # noqa: E501\nfor citation in [\nCitationAdministrativeCase,\nCitationAdministrativeMatter,\nCitationBarMatter,\nCitationGeneralRegister,\n]:\nyield from citation.search(raw)\n</code></pre>"},{"location":"api-extraction/#extract_docket_from_data","title":"extract_docket_from_data()","text":"<p>Return a DocketReportCitationType based on contents of a <code>data</code> dict.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from citation_docket import extract_docket_from_data\n&gt;&gt;&gt; data = {\n    \"date_prom\": \"1985-04-24\",\n    \"docket\": \"General Register L-63915, April 24, 1985\",\n    \"orig_idx\": \"GR No. L-63915\",\n    \"phil\": \"220 Phil. 422\",\n    \"scra\": \"136 SCRA 27\",\n    \"offg\": None,\n} # assume transformation from /details.yaml file\n&gt;&gt;&gt; extract_citation_from_data(data)\n'CitationGeneralRegister(publisher=None, volume=None, page=None, volpubpage=None, report_date=None, context='G.R. No. L-63915', short_category='GR', category='General Register', ids='L-63915', docket_date=datetime.date(1985, 4, 24))'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Should contain relevant keys.</p> required <p>Returns:</p> Name Type Description <code>DocketReportCitationType</code> <code>DocketReportCitationType | None</code> <p>description</p> Source code in <code>citation_docket/__main__.py</code> Python<pre><code>def extract_docket_from_data(data: dict) -&gt; DocketReportCitationType | None:\n\"\"\"\n    Return a DocketReportCitationType based on contents of a `data` dict.\n    Examples:\n        &gt;&gt;&gt; from citation_docket import extract_docket_from_data\n        &gt;&gt;&gt; data = {\n            \"date_prom\": \"1985-04-24\",\n            \"docket\": \"General Register L-63915, April 24, 1985\",\n            \"orig_idx\": \"GR No. L-63915\",\n            \"phil\": \"220 Phil. 422\",\n            \"scra\": \"136 SCRA 27\",\n            \"offg\": None,\n        } # assume transformation from /details.yaml file\n        &gt;&gt;&gt; extract_citation_from_data(data)\n        'CitationGeneralRegister(publisher=None, volume=None, page=None, volpubpage=None, report_date=None, context='G.R. No. L-63915', short_category='GR', category='General Register', ids='L-63915', docket_date=datetime.date(1985, 4, 24))'\n    Args:\n        data (dict): Should contain relevant keys.\n    Returns:\n        DocketReportCitationType: _description_\n    \"\"\"  # noqa: E501\ntry:\nreturn next(extract_dockets(setup_docket_field(data)))\nexcept Exception:\nreturn None\n</code></pre>"},{"location":"api-types/","title":"Specific Types","text":""},{"location":"api-types/#docket-report-citation","title":"Docket Report Citation","text":"<p>         Bases: <code>Docket</code>, <code>Report</code>, <code>abc.ABC</code></p> <p>Note <code>Report</code> is defined in a separate library <code>citation-report</code>.</p> <p>The <code>DocketReportCitation</code> abstract class makes sure that all of the fields of a Docket object alongside all of the fields of a <code>Report</code> object will be utilized. It also mandates the implementation of a<code>cls.search()</code> method.</p> Source code in <code>citation_docket/regexes/models/docket_citation.py</code> Python<pre><code>class DocketReportCitation(Docket, Report, abc.ABC):\n\"\"\"Note `Report` is defined in a separate library `citation-report`.\n    The `DocketReportCitation` abstract class makes sure that all of the\n    fields of a [Docket][docket-model] object alongside all of the fields of a `Report`\n    object will be utilized. It also mandates the implementation of a`cls.search()`\n    method.\n    \"\"\"\n...\n@classmethod\n@abc.abstractmethod\ndef search(cls, raw: str) -&gt; Iterator[Self]:\nraise NotImplementedError(\n\"Each docket citation must have a search method that produces an\"\n\" Iterator of the class instance.\"\n)\n</code></pre>"},{"location":"api-types/#general-register","title":"General Register","text":"<p>         Bases: <code>DocketReportCitation</code></p> Source code in <code>citation_docket/regexes/constructed_gr.py</code> Python<pre><code>class CitationGeneralRegister(DocketReportCitation):\n...\n@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `GR` docket pattern, inclusive of their optional Report object.\n        Examples:\n            &gt;&gt;&gt; text = \"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"\n            &gt;&gt;&gt; next(CitationGeneralRegister.search(text))\n            CitationGeneralRegister(publisher='SCRA', volume='342', page='449', volpubpage='342 SCRA 449', report_date=None, context='G.R. Nos. 138570, 138572, 138587, 138680, 138698', short_category='GR', category='General Register', ids='138570, 138572, 138587, 138680, 138698', docket_date=datetime.date(2000, 10, 10))\n        Args:\n            text (str): Text to look for citation objects\n        Yields:\n            Iterator[Self]: Combination of Docket and Report pydantic model.\n        \"\"\"  # noqa E501\nfor result in constructed_gr.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"api-types/#citation_docket.regexes.constructed_gr.CitationGeneralRegister-functions","title":"Functions","text":""},{"location":"api-types/#citation_docket.regexes.constructed_gr.CitationGeneralRegister.search","title":"<code>search(text)</code>  <code>classmethod</code>","text":"<p>Get all dockets matching the <code>GR</code> docket pattern, inclusive of their optional Report object.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"\n&gt;&gt;&gt; next(CitationGeneralRegister.search(text))\nCitationGeneralRegister(publisher='SCRA', volume='342', page='449', volpubpage='342 SCRA 449', report_date=None, context='G.R. Nos. 138570, 138572, 138587, 138680, 138698', short_category='GR', category='General Register', ids='138570, 138572, 138587, 138680, 138698', docket_date=datetime.date(2000, 10, 10))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for citation objects</p> required <p>Yields:</p> Type Description <code>Iterator[Self]</code> <p>Iterator[Self]: Combination of Docket and Report pydantic model.</p> Source code in <code>citation_docket/regexes/constructed_gr.py</code> Python<pre><code>@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `GR` docket pattern, inclusive of their optional Report object.\n    Examples:\n        &gt;&gt;&gt; text = \"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"\n        &gt;&gt;&gt; next(CitationGeneralRegister.search(text))\n        CitationGeneralRegister(publisher='SCRA', volume='342', page='449', volpubpage='342 SCRA 449', report_date=None, context='G.R. Nos. 138570, 138572, 138587, 138680, 138698', short_category='GR', category='General Register', ids='138570, 138572, 138587, 138680, 138698', docket_date=datetime.date(2000, 10, 10))\n    Args:\n        text (str): Text to look for citation objects\n    Yields:\n        Iterator[Self]: Combination of Docket and Report pydantic model.\n    \"\"\"  # noqa E501\nfor result in constructed_gr.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"api-types/#administrative-matter","title":"Administrative Matter","text":"<p>         Bases: <code>DocketReportCitation</code></p> Source code in <code>citation_docket/regexes/constructed_am.py</code> Python<pre><code>class CitationAdministrativeMatter(DocketReportCitation):\n...\n@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `AM` docket pattern, inclusive of their optional Report object.\n        Examples:\n            &gt;&gt;&gt; text = \"A.M. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n            &gt;&gt;&gt; next(CitationAdministrativeMatter.search(text))\n            CitationAdministrativeMatter(publisher='SCRA', volume='206', page='491', volpubpage='206 SCRA 491', report_date=None, context='A.M. No. P-88-198', short_category='AM', category='Administrative Matter', ids='P-88-198', docket_date=datetime.date(1992, 2, 25))\n        Args:\n            text (str): Text to look for citation objects\n        Yields:\n            Iterator[Self]: Combination of Docket and Report pydantic model.\n        \"\"\"  # noqa E501\nfor result in constructed_am.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"api-types/#citation_docket.regexes.constructed_am.CitationAdministrativeMatter-functions","title":"Functions","text":""},{"location":"api-types/#citation_docket.regexes.constructed_am.CitationAdministrativeMatter.search","title":"<code>search(text)</code>  <code>classmethod</code>","text":"<p>Get all dockets matching the <code>AM</code> docket pattern, inclusive of their optional Report object.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"A.M. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n&gt;&gt;&gt; next(CitationAdministrativeMatter.search(text))\nCitationAdministrativeMatter(publisher='SCRA', volume='206', page='491', volpubpage='206 SCRA 491', report_date=None, context='A.M. No. P-88-198', short_category='AM', category='Administrative Matter', ids='P-88-198', docket_date=datetime.date(1992, 2, 25))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for citation objects</p> required <p>Yields:</p> Type Description <code>Iterator[Self]</code> <p>Iterator[Self]: Combination of Docket and Report pydantic model.</p> Source code in <code>citation_docket/regexes/constructed_am.py</code> Python<pre><code>@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `AM` docket pattern, inclusive of their optional Report object.\n    Examples:\n        &gt;&gt;&gt; text = \"A.M. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n        &gt;&gt;&gt; next(CitationAdministrativeMatter.search(text))\n        CitationAdministrativeMatter(publisher='SCRA', volume='206', page='491', volpubpage='206 SCRA 491', report_date=None, context='A.M. No. P-88-198', short_category='AM', category='Administrative Matter', ids='P-88-198', docket_date=datetime.date(1992, 2, 25))\n    Args:\n        text (str): Text to look for citation objects\n    Yields:\n        Iterator[Self]: Combination of Docket and Report pydantic model.\n    \"\"\"  # noqa E501\nfor result in constructed_am.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"api-types/#administrative-case","title":"Administrative Case","text":"<p>         Bases: <code>DocketReportCitation</code></p> Source code in <code>citation_docket/regexes/constructed_ac.py</code> Python<pre><code>class CitationAdministrativeCase(DocketReportCitation):\n...\n@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `AC` docket pattern, inclusive of their optional Report object.\n        Examples:\n            &gt;&gt;&gt; text = \"A.C. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n            &gt;&gt;&gt; next(CitationAdministrativeCase.search(text))\n            CitationAdministrativeCase(publisher='SCRA', volume='206', page='491', volpubpage='206 SCRA 491', report_date=None, context='A.C. No. P-88-198', short_category='AC', category='Administrative Case', ids='P-88-198', docket_date=datetime.date(1992, 2, 25))\n        Args:\n            text (str): Text to look for citation objects\n        Yields:\n            Iterator[Self]: Combination of Docket and Report pydantic model.\n        \"\"\"  # noqa E501\nfor result in constructed_ac.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"api-types/#citation_docket.regexes.constructed_ac.CitationAdministrativeCase-functions","title":"Functions","text":""},{"location":"api-types/#citation_docket.regexes.constructed_ac.CitationAdministrativeCase.search","title":"<code>search(text)</code>  <code>classmethod</code>","text":"<p>Get all dockets matching the <code>AC</code> docket pattern, inclusive of their optional Report object.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"A.C. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n&gt;&gt;&gt; next(CitationAdministrativeCase.search(text))\nCitationAdministrativeCase(publisher='SCRA', volume='206', page='491', volpubpage='206 SCRA 491', report_date=None, context='A.C. No. P-88-198', short_category='AC', category='Administrative Case', ids='P-88-198', docket_date=datetime.date(1992, 2, 25))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for citation objects</p> required <p>Yields:</p> Type Description <code>Iterator[Self]</code> <p>Iterator[Self]: Combination of Docket and Report pydantic model.</p> Source code in <code>citation_docket/regexes/constructed_ac.py</code> Python<pre><code>@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `AC` docket pattern, inclusive of their optional Report object.\n    Examples:\n        &gt;&gt;&gt; text = \"A.C. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n        &gt;&gt;&gt; next(CitationAdministrativeCase.search(text))\n        CitationAdministrativeCase(publisher='SCRA', volume='206', page='491', volpubpage='206 SCRA 491', report_date=None, context='A.C. No. P-88-198', short_category='AC', category='Administrative Case', ids='P-88-198', docket_date=datetime.date(1992, 2, 25))\n    Args:\n        text (str): Text to look for citation objects\n    Yields:\n        Iterator[Self]: Combination of Docket and Report pydantic model.\n    \"\"\"  # noqa E501\nfor result in constructed_ac.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"api-types/#bar-matter","title":"Bar Matter","text":"<p>         Bases: <code>DocketReportCitation</code></p> Source code in <code>citation_docket/regexes/constructed_bm.py</code> Python<pre><code>class CitationBarMatter(DocketReportCitation):\n...\n@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `BM` docket pattern, inclusive of their optional Report object.\n        Examples:\n            &gt;&gt;&gt; text = \"B.M. No. 1678, December 17, 2007\"\n            &gt;&gt;&gt; next(CitationBarMatter.search(text))\n            CitationBarMatter(publisher=None, volume=None, page=None, volpubpage=None, report_date=None, context='B.M. No. 1678', short_category='BM', category='Bar Matter', ids='1678', docket_date=datetime.date(2007, 12, 17))\n        Args:\n            text (str): Text to look for citation objects\n        Yields:\n            Iterator[Self]: Combination of Docket and Report pydantic model.\n        \"\"\"  # noqa E501\nfor result in constructed_bm.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"api-types/#citation_docket.regexes.constructed_bm.CitationBarMatter-functions","title":"Functions","text":""},{"location":"api-types/#citation_docket.regexes.constructed_bm.CitationBarMatter.search","title":"<code>search(text)</code>  <code>classmethod</code>","text":"<p>Get all dockets matching the <code>BM</code> docket pattern, inclusive of their optional Report object.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"B.M. No. 1678, December 17, 2007\"\n&gt;&gt;&gt; next(CitationBarMatter.search(text))\nCitationBarMatter(publisher=None, volume=None, page=None, volpubpage=None, report_date=None, context='B.M. No. 1678', short_category='BM', category='Bar Matter', ids='1678', docket_date=datetime.date(2007, 12, 17))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for citation objects</p> required <p>Yields:</p> Type Description <code>Iterator[Self]</code> <p>Iterator[Self]: Combination of Docket and Report pydantic model.</p> Source code in <code>citation_docket/regexes/constructed_bm.py</code> Python<pre><code>@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `BM` docket pattern, inclusive of their optional Report object.\n    Examples:\n        &gt;&gt;&gt; text = \"B.M. No. 1678, December 17, 2007\"\n        &gt;&gt;&gt; next(CitationBarMatter.search(text))\n        CitationBarMatter(publisher=None, volume=None, page=None, volpubpage=None, report_date=None, context='B.M. No. 1678', short_category='BM', category='Bar Matter', ids='1678', docket_date=datetime.date(2007, 12, 17))\n    Args:\n        text (str): Text to look for citation objects\n    Yields:\n        Iterator[Self]: Combination of Docket and Report pydantic model.\n    \"\"\"  # noqa E501\nfor result in constructed_bm.detect(text):\nyield cls(**result)\n</code></pre>"}]}