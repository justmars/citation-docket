{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Overall strategy</p> <p>Like citation-reports, there is a problem involving inconsistent use of values citations. We address it the same way by dissecting the component parts and generating a uniform citation.</p> <p>The component parts of a Supreme Court decision citation:</p> <pre><code>flowchart TB\ncite(citation)---docket\ncite---report\ndocket---d1(docket category)\ndocket---d2(docket serial)\ndocket---d3(docket date)\nreport---r1(phil)\nreport---r2(scra)\nreport---r3(offg)</code></pre> <p>Sample citation, typically found in the body and the footnotes section of a decision:</p> <p>Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449</p> <p>Dissecting the above yields</p> case title docket category docket serial docket date report phil report scra report offg Bagong Alyansang... <code>gr</code> 138570 2000-10-10 - 342 SCRA 449 -"},{"location":"#citation","title":"Citation","text":"<p>The <code>Report</code> Model from citation-report is only one part of a Philippine Supreme Court citation. This library will handle the patterns involved with respect to the Docket, for the purpose of creating a Citation.</p> <p>         Bases: <code>BaseModel</code></p> <p>A Philippine Supreme Court <code>Citation</code> consists of:</p> <ol> <li><code>Docket</code> includes:<ol> <li>category,</li> <li>serial number, and</li> <li>date.</li> </ol> </li> <li><code>Report</code> - as defined in citation-report - includes:<ol> <li>volume number,</li> <li>identifying acronym of the reporter/publisher,</li> <li>page of the reported volume.</li> </ol> </li> </ol> <p>It is typical to see a <code>Docket</code> combined with a <code>Report</code>:</p> <p>Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449</p> <p>Taken together (and using Bagong Alyansang Makabayan as an example) the text above can be extracted into fields:</p> Example Field Type Description GR <code>docket_category</code> optional (<code>ShortDocketCategory</code>) See shorthand 138570 <code>docket_serial</code> optional (str) See serialized identifier datetime.date(2000, 10, 10) <code>docket_date</code> optional (date) When docket serial issued GR 138570, Oct. 10, 2000 <code>docket</code> optional (str) Combined <code>docket_category</code> <code>docket_serial</code> <code>docket_date</code> None <code>phil</code> optional (str) combined <code>volume</code> Phil. <code>page</code> 342 SCRA 449 <code>scra</code> optional (str) combined <code>volume</code> SCRA <code>page</code> None <code>offg</code> optional (str) combined <code>volume</code> O.G. <code>page</code> Source code in <code>citation_utils/citation.py</code> Python<pre><code>class Citation(BaseModel):\n\"\"\"\n    A Philippine Supreme Court `Citation` consists of:\n    1. `Docket` includes:\n        1. _category_,\n        2. _serial number_, and\n        3. _date_.\n    2. `Report` - as defined in [citation-report](https://github.com/justmars/citation-report) - includes:\n        1. _volume number_,\n        2. _identifying acronym of the reporter/publisher_,\n        3. _page of the reported volume_.\n    It is typical to see a `Docket` combined with a `Report`:\n    &gt; _Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449_\n    Taken together (and using _Bagong Alyansang Makabayan_ as an example) the text above can be extracted into fields:\n    Example | Field | Type | Description\n    --:|:--:|:--|--:\n    GR | `docket_category` | optional (`ShortDocketCategory`) | See shorthand\n    138570 |`docket_serial` | optional (str) | See serialized identifier\n    datetime.date(2000, 10, 10) | `docket_date` | optional (date) | When docket serial issued\n    GR 138570, Oct. 10, 2000 | `docket` | optional (str) | Combined `docket_category` `docket_serial` `docket_date`\n    None | `phil` | optional (str) | combined `volume` Phil. `page`\n    342 SCRA 449 | `scra` | optional (str) | combined `volume` SCRA `page`\n    None | `offg` | optional (str) | combined `volume` O.G. `page`\n    \"\"\"  # noqa: E501\nmodel_config = ConfigDict(use_enum_values=True, str_strip_whitespace=True)\ndocket_category: DocketCategory | None = Field(None)\ndocket_serial: str | None = Field(None)\ndocket_date: datetime.date | None = Field(None)\ndocket: str | None = Field(None, description=\"Category + single serial id + date\")\nphil: str | None = Field(None, description=\"vol + Phil. (pub) + page\")\nscra: str | None = Field(None, description=\"vol + SCRA (pub) + page\")\noffg: str | None = Field(None, description=\"vol + O.G. (pub) + page\")\n@property\ndef elements(self) -&gt; list[str]:\nbits = []\nif self.docket:\nbits.append(self.docket)\nif self.phil:\nbits.append(self.phil)\nif self.scra:\nbits.append(self.scra)\nif self.offg:\nbits.append(self.offg)\nreturn bits\ndef __repr__(self) -&gt; str:\nreturn f\"&lt;Citation: {str(self)}&gt;\"\ndef __str__(self) -&gt; str:\nreturn \", \".join(self.elements) if self.elements else \"Bad citation.\"\ndef __eq__(self, other: Self) -&gt; bool:\nok_cat = self.docket_category is not None and other.docket_category is not None\nok_serial = self.docket_serial is not None and other.docket_serial is not None\nok_date = self.docket_date is not None and other.docket_date is not None\nreturn any(\n[\nis_eq(self.docket, other.docket),\nis_eq(self.scra, other.scra),\nis_eq(self.offg, other.offg),\nis_eq(self.phil, other.phil),\nall(\n[\nok_cat and (self.docket_category == other.docket_category),\nok_serial and (self.docket_serial == other.docket_serial),\nok_date and (self.docket_date == other.docket_date),\n]\n),\n]\n)\n@classmethod\ndef _set_report(cls, text: str):\ntry:\nobj = next(Report.extract_reports(text))\nreturn cls(\ndocket=None,\ndocket_category=None,\ndocket_serial=None,\ndocket_date=None,\nphil=obj.phil,\nscra=obj.scra,\noffg=obj.offg,\n)\nexcept StopIteration:\nlogging.debug(f\"{text} is not a Report instance.\")\nreturn None\n@classmethod\ndef _set_docket_report(cls, text: str):\ntry:\nobj = next(CitableDocument.get_docketed_reports(text))\nreturn cls(\ndocket=f\"{obj.category} {obj.serial_text}, {obj.docket_date}\",\ndocket_category=obj.category,\ndocket_serial=obj.serial_text,\ndocket_date=obj.docket_date,\nphil=obj.phil,\nscra=obj.scra,\noffg=obj.offg,\n)\nexcept StopIteration:\nlogging.debug(f\"{text} is not a Docket nor a Report instance.\")\nreturn None\n@classmethod\ndef extract_citations(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Find citations and parse resulting strings to determine whether they are:\n        1. `Docket` + `Report` objects (in which case, `_set_docket_report()` will be used); or\n        2. `Report` objects (in which case `_set_report()` will be used)\n        Then processing each object so that they can be structured in a uniform format.\n        Examples:\n            &gt;&gt;&gt; text = \"&lt;em&gt;Gatchalian Promotions Talent Pool, Inc. v. Atty. Naldoza&lt;/em&gt;, 374 Phil. 1, 10-11 (1999), citing: &lt;em&gt;In re Almacen&lt;/em&gt;, 31 SCRA 562, 600 (1970).; People v. Umayam, G.R. No. 147033, April 30, 2003; &lt;i&gt;Bagong Alyansang Makabayan v. Zamora,&lt;/i&gt; G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449; Villegas &lt;em&gt;v.&lt;/em&gt; Subido, G.R. No. 31711, Sept. 30, 1971, 41 SCRA 190;\"\n            &gt;&gt;&gt; len(list(Citation.extract_citations(text)))\n            5\n        Args:\n            text (str): Text to evaluate\n        Yields:\n            Iterator[Self]: Itemized citations pre-processed via `CitableDocument`\n        \"\"\"  # noqa: E501\nfor cite in CitableDocument(text=text).get_citations():\nif _docket := cls._set_docket_report(cite):\nyield _docket\nelif _report := cls._set_report(cite):\nyield _report\nelse:\nlogging.error(f\"Skip invalid {cite=}.\")\n@classmethod\ndef extract_citation(cls, text: str) -&gt; Self | None:\n\"\"\"Thin wrapper over `cls.extract_citations()`.\n        Examples:\n            &gt;&gt;&gt; Citation.extract_citation('Hello World') is None\n            True\n            &gt;&gt;&gt; next(Citation.extract_citations('12 Phil. 24'))\n            &lt;Citation: 12 Phil. 24&gt;\n        Args:\n            text (str): Text to evaluate\n        Returns:\n            Self | None: First item found from `extract_citations`, if it exists.\n        \"\"\"\ntry:\nreturn next(cls.extract_citations(text))\nexcept StopIteration:\nreturn None\n</code></pre>"},{"location":"#citation_utils.Citation-functions","title":"Functions","text":""},{"location":"#citation_utils.citation.Citation.extract_citation","title":"<code>extract_citation(text)</code>  <code>classmethod</code>","text":"<p>Thin wrapper over <code>cls.extract_citations()</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; Citation.extract_citation('Hello World') is None\nTrue\n&gt;&gt;&gt; next(Citation.extract_citations('12 Phil. 24'))\n&lt;Citation: 12 Phil. 24&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to evaluate</p> required <p>Returns:</p> Type Description <code>Self | None</code> <p>Self | None: First item found from <code>extract_citations</code>, if it exists.</p> Source code in <code>citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef extract_citation(cls, text: str) -&gt; Self | None:\n\"\"\"Thin wrapper over `cls.extract_citations()`.\n    Examples:\n        &gt;&gt;&gt; Citation.extract_citation('Hello World') is None\n        True\n        &gt;&gt;&gt; next(Citation.extract_citations('12 Phil. 24'))\n        &lt;Citation: 12 Phil. 24&gt;\n    Args:\n        text (str): Text to evaluate\n    Returns:\n        Self | None: First item found from `extract_citations`, if it exists.\n    \"\"\"\ntry:\nreturn next(cls.extract_citations(text))\nexcept StopIteration:\nreturn None\n</code></pre>"},{"location":"#citation_utils.citation.Citation.extract_citations","title":"<code>extract_citations(text)</code>  <code>classmethod</code>","text":"<p>Find citations and parse resulting strings to determine whether they are:</p> <ol> <li><code>Docket</code> + <code>Report</code> objects (in which case, <code>_set_docket_report()</code> will be used); or</li> <li><code>Report</code> objects (in which case <code>_set_report()</code> will be used)</li> </ol> <p>Then processing each object so that they can be structured in a uniform format.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"&lt;em&gt;Gatchalian Promotions Talent Pool, Inc. v. Atty. Naldoza&lt;/em&gt;, 374 Phil. 1, 10-11 (1999), citing: &lt;em&gt;In re Almacen&lt;/em&gt;, 31 SCRA 562, 600 (1970).; People v. Umayam, G.R. No. 147033, April 30, 2003; &lt;i&gt;Bagong Alyansang Makabayan v. Zamora,&lt;/i&gt; G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449; Villegas &lt;em&gt;v.&lt;/em&gt; Subido, G.R. No. 31711, Sept. 30, 1971, 41 SCRA 190;\"\n&gt;&gt;&gt; len(list(Citation.extract_citations(text)))\n5\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to evaluate</p> required <p>Yields:</p> Type Description <code>Self</code> <p>Iterator[Self]: Itemized citations pre-processed via <code>CitableDocument</code></p> Source code in <code>citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef extract_citations(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Find citations and parse resulting strings to determine whether they are:\n    1. `Docket` + `Report` objects (in which case, `_set_docket_report()` will be used); or\n    2. `Report` objects (in which case `_set_report()` will be used)\n    Then processing each object so that they can be structured in a uniform format.\n    Examples:\n        &gt;&gt;&gt; text = \"&lt;em&gt;Gatchalian Promotions Talent Pool, Inc. v. Atty. Naldoza&lt;/em&gt;, 374 Phil. 1, 10-11 (1999), citing: &lt;em&gt;In re Almacen&lt;/em&gt;, 31 SCRA 562, 600 (1970).; People v. Umayam, G.R. No. 147033, April 30, 2003; &lt;i&gt;Bagong Alyansang Makabayan v. Zamora,&lt;/i&gt; G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449; Villegas &lt;em&gt;v.&lt;/em&gt; Subido, G.R. No. 31711, Sept. 30, 1971, 41 SCRA 190;\"\n        &gt;&gt;&gt; len(list(Citation.extract_citations(text)))\n        5\n    Args:\n        text (str): Text to evaluate\n    Yields:\n        Iterator[Self]: Itemized citations pre-processed via `CitableDocument`\n    \"\"\"  # noqa: E501\nfor cite in CitableDocument(text=text).get_citations():\nif _docket := cls._set_docket_report(cite):\nyield _docket\nelif _report := cls._set_report(cite):\nyield _report\nelse:\nlogging.error(f\"Skip invalid {cite=}.\")\n</code></pre>"},{"location":"#countedcitation","title":"CountedCitation","text":"<p>         Bases: <code>Citation</code></p> Source code in <code>citation_utils/citation.py</code> Python<pre><code>class CountedCitation(Citation):\nmentions: int = Field(default=1, description=\"Get count via Citation __eq__\")\ndef __repr__(self) -&gt; str:\nreturn f\"{str(self)}: {self.mentions}\"\ndef __str__(self) -&gt; str:\ndocket_str = None\nif all([self.docket_category, self.docket_serial, self.docket_date]):\ndocket_str = f\"{self.docket_category} No. {self.docket_serial}, {self.docket_date.strftime('%b %d, %Y')}\"  # type: ignore # noqa: E501\nreport_str = None\nif any([self.phil, self.scra, self.offg]):\nreport_str = self.phil or self.scra or self.offg\nif docket_str and report_str:\nreturn f\"{docket_str}, {report_str}\"\nelif docket_str:\nreturn f\"{docket_str}\"\nelif report_str:\nreturn f\"{report_str}\"\nelse:\nreturn \"&lt;Bad citation str&gt;\"\n@classmethod\ndef from_source(cls, text: str) -&gt; list[Self]:\n\"\"\"Computes mentions of `counted_dockets()` vis-a-vis `counted_reports()` and\n        count the number of unique items, taking into account the Citation\n        structure and the use of __eq__ re: what is considered unique.\n        Examples:\n            &gt;&gt;&gt; source = \"374 Phil. 1, 10-11 (1999) 1111 SCRA 1111; G.R. No. 147033, April 30, 2003; G.R. No. 147033, April 30, 2003, 374 Phil. 1, 600; ABC v. XYZ, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449;  XXX, G.R. No. 31711, Sept. 30, 1971, 35 SCRA 190; Hello World, 1111 SCRA 1111; Y v. Z, 35 SCRA 190; 1 Off. Gaz. 41 Bar Matter No. 803, Jan. 1, 2000 Bar Matter No. 411, Feb. 1, 2000 Bar Matter No. 412, Jan. 1, 2000, 1111 SCRA 1111; 374 Phil. 1\"\n            &gt;&gt;&gt; list(CountedCitation.from_source(source))\n            [BM No. 412, Jan 01, 2000, 1111 SCRA 1111: 3, GR No. 147033, Apr 30, 2003, 374 Phil. 1: 3, GR No. 138570, Oct 10, 2000, 342 SCRA 449: 1, GR No. 31711, Sep 30, 1971, 35 SCRA 190: 2, 1 Off. Gaz. 41: 1]\n        Args:\n            text (str): Text to Evaluate.\n        Returns:\n            list[Self]: Unique citations with their counts.\n        \"\"\"  # noqa: E501\nall_reports = cls.counted_reports(text)  # includes reports in docket_reports\ndocket_reports = cls.counted_docket_reports(text)\nfor report in all_reports:\nfor dr in docket_reports:\nif report == dr:  # uses Citation __eq__\nbalance = 0\nif report.mentions &gt; dr.mentions:\nbalance = report.mentions - dr.mentions\ndr.mentions = dr.mentions + balance\nreport.mentions = 0\nreturn docket_reports + [\nreport for report in all_reports if report.mentions &gt; 0\n]\n@classmethod\ndef from_repr_format(cls, repr_texts: list[str]) -&gt; Iterator[Self]:\n\"\"\"Generate their pydantic counterparts from `&lt;cat&gt; &lt;id&gt;: &lt;mentions&gt;` format.\n        Examples:\n            &gt;&gt;&gt; repr_texts = ['BM No. 412, Jan 01, 2000, 1111 SCRA 1111: 3', 'GR No. 147033, Apr 30, 2003, 374 Phil. 1: 3']\n            &gt;&gt;&gt; results = list(CountedCitation.from_repr_format(repr_texts))\n            &gt;&gt;&gt; len(results)\n            2\n        Args:\n            repr_texts (str): list of texts having `__repr__` format of a `CountedRule`\n        Yields:\n            Iterator[Self]: Instances of CountedCitation.\n        \"\"\"  # noqa: E501\nfor text in repr_texts:\ncounted_bits = text.split(\":\")\nif len(counted_bits) == 2:\nif cite := cls.extract_citation(counted_bits[0].strip()):\nobj = cite.model_dump()\ncitation = cls(**obj)\ncitation.mentions = int(counted_bits[1].strip())\nyield citation\n@classmethod\ndef counted_reports(cls, text: str):\n\"\"\"Detect _reports_ only from source `text` by first converting\n        raw citations into a `Citation` object to take advantage of `__eq__` in\n        a `seen` list. This will also populate the the unique records with missing\n        values.\n        \"\"\"\nseen: list[cls] = []\nreports = Report.extract_reports(text=text)\nfor report in reports:\ncite = Citation(\ndocket=None,\ndocket_category=None,\ndocket_serial=None,\ndocket_date=None,\nphil=report.phil,\nscra=report.scra,\noffg=report.offg,\n)\nif cite not in seen:\nseen.append(cls(**cite.model_dump()))\nelse:\nincluded = seen[seen.index(cite)]\nincluded.mentions += 1\nreturn seen\n@classmethod\ndef counted_docket_reports(cls, text: str):\n\"\"\"Detect _dockets with reports_ from source `text` by first converting\n        raw citations into a `Citation` object to take advantage of `__eq__` in\n        a `seen` list. This will also populate the the unique records with missing\n        values.\n        \"\"\"\nseen: list[cls] = []\nfor obj in CitableDocument.get_docketed_reports(text=text):\ncite = Citation(\ndocket=str(obj),\ndocket_category=obj.category,\ndocket_serial=obj.serial_text,\ndocket_date=obj.docket_date,\nphil=obj.phil,\nscra=obj.scra,\noffg=obj.offg,\n)\nif cite not in seen:\nseen.append(cls(**cite.model_dump()))\nelse:\nincluded = seen[seen.index(cite)]\nincluded.mentions += 1\nincluded.add_values(cite)  # for citations, can add missing\nreturn seen\ndef add_values(self, other: Citation):\nif not self.docket_category and other.docket_category:\nself.docket_category = other.docket_category\nif not self.docket_serial and other.docket_serial:\nself.docket_serial = other.docket_serial\nif not self.docket_date and other.docket_date:\nself.docket_date = other.docket_date\nif not self.docket and other.docket:\nself.docket = other.docket\nif not self.scra and other.scra:\nself.scra = other.scra\nif not self.phil and other.phil:\nself.phil = other.phil\nif not self.offg and other.offg:\nself.offg = other.offg\n</code></pre>"},{"location":"#citation_utils.CountedCitation-functions","title":"Functions","text":""},{"location":"#citation_utils.citation.CountedCitation.counted_docket_reports","title":"<code>counted_docket_reports(text)</code>  <code>classmethod</code>","text":"<p>Detect dockets with reports from source <code>text</code> by first converting raw citations into a <code>Citation</code> object to take advantage of <code>__eq__</code> in a <code>seen</code> list. This will also populate the the unique records with missing values.</p> Source code in <code>citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef counted_docket_reports(cls, text: str):\n\"\"\"Detect _dockets with reports_ from source `text` by first converting\n    raw citations into a `Citation` object to take advantage of `__eq__` in\n    a `seen` list. This will also populate the the unique records with missing\n    values.\n    \"\"\"\nseen: list[cls] = []\nfor obj in CitableDocument.get_docketed_reports(text=text):\ncite = Citation(\ndocket=str(obj),\ndocket_category=obj.category,\ndocket_serial=obj.serial_text,\ndocket_date=obj.docket_date,\nphil=obj.phil,\nscra=obj.scra,\noffg=obj.offg,\n)\nif cite not in seen:\nseen.append(cls(**cite.model_dump()))\nelse:\nincluded = seen[seen.index(cite)]\nincluded.mentions += 1\nincluded.add_values(cite)  # for citations, can add missing\nreturn seen\n</code></pre>"},{"location":"#citation_utils.citation.CountedCitation.counted_reports","title":"<code>counted_reports(text)</code>  <code>classmethod</code>","text":"<p>Detect reports only from source <code>text</code> by first converting raw citations into a <code>Citation</code> object to take advantage of <code>__eq__</code> in a <code>seen</code> list. This will also populate the the unique records with missing values.</p> Source code in <code>citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef counted_reports(cls, text: str):\n\"\"\"Detect _reports_ only from source `text` by first converting\n    raw citations into a `Citation` object to take advantage of `__eq__` in\n    a `seen` list. This will also populate the the unique records with missing\n    values.\n    \"\"\"\nseen: list[cls] = []\nreports = Report.extract_reports(text=text)\nfor report in reports:\ncite = Citation(\ndocket=None,\ndocket_category=None,\ndocket_serial=None,\ndocket_date=None,\nphil=report.phil,\nscra=report.scra,\noffg=report.offg,\n)\nif cite not in seen:\nseen.append(cls(**cite.model_dump()))\nelse:\nincluded = seen[seen.index(cite)]\nincluded.mentions += 1\nreturn seen\n</code></pre>"},{"location":"#citation_utils.citation.CountedCitation.from_repr_format","title":"<code>from_repr_format(repr_texts)</code>  <code>classmethod</code>","text":"<p>Generate their pydantic counterparts from <code>&lt;cat&gt; &lt;id&gt;: &lt;mentions&gt;</code> format.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; repr_texts = ['BM No. 412, Jan 01, 2000, 1111 SCRA 1111: 3', 'GR No. 147033, Apr 30, 2003, 374 Phil. 1: 3']\n&gt;&gt;&gt; results = list(CountedCitation.from_repr_format(repr_texts))\n&gt;&gt;&gt; len(results)\n2\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>repr_texts</code> <code>str</code> <p>list of texts having <code>__repr__</code> format of a <code>CountedRule</code></p> required <p>Yields:</p> Type Description <code>Self</code> <p>Iterator[Self]: Instances of CountedCitation.</p> Source code in <code>citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef from_repr_format(cls, repr_texts: list[str]) -&gt; Iterator[Self]:\n\"\"\"Generate their pydantic counterparts from `&lt;cat&gt; &lt;id&gt;: &lt;mentions&gt;` format.\n    Examples:\n        &gt;&gt;&gt; repr_texts = ['BM No. 412, Jan 01, 2000, 1111 SCRA 1111: 3', 'GR No. 147033, Apr 30, 2003, 374 Phil. 1: 3']\n        &gt;&gt;&gt; results = list(CountedCitation.from_repr_format(repr_texts))\n        &gt;&gt;&gt; len(results)\n        2\n    Args:\n        repr_texts (str): list of texts having `__repr__` format of a `CountedRule`\n    Yields:\n        Iterator[Self]: Instances of CountedCitation.\n    \"\"\"  # noqa: E501\nfor text in repr_texts:\ncounted_bits = text.split(\":\")\nif len(counted_bits) == 2:\nif cite := cls.extract_citation(counted_bits[0].strip()):\nobj = cite.model_dump()\ncitation = cls(**obj)\ncitation.mentions = int(counted_bits[1].strip())\nyield citation\n</code></pre>"},{"location":"#citation_utils.citation.CountedCitation.from_source","title":"<code>from_source(text)</code>  <code>classmethod</code>","text":"<p>Computes mentions of <code>counted_dockets()</code> vis-a-vis <code>counted_reports()</code> and count the number of unique items, taking into account the Citation structure and the use of eq re: what is considered unique.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; source = \"374 Phil. 1, 10-11 (1999) 1111 SCRA 1111; G.R. No. 147033, April 30, 2003; G.R. No. 147033, April 30, 2003, 374 Phil. 1, 600; ABC v. XYZ, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449;  XXX, G.R. No. 31711, Sept. 30, 1971, 35 SCRA 190; Hello World, 1111 SCRA 1111; Y v. Z, 35 SCRA 190; 1 Off. Gaz. 41 Bar Matter No. 803, Jan. 1, 2000 Bar Matter No. 411, Feb. 1, 2000 Bar Matter No. 412, Jan. 1, 2000, 1111 SCRA 1111; 374 Phil. 1\"\n&gt;&gt;&gt; list(CountedCitation.from_source(source))\n[BM No. 412, Jan 01, 2000, 1111 SCRA 1111: 3, GR No. 147033, Apr 30, 2003, 374 Phil. 1: 3, GR No. 138570, Oct 10, 2000, 342 SCRA 449: 1, GR No. 31711, Sep 30, 1971, 35 SCRA 190: 2, 1 Off. Gaz. 41: 1]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to Evaluate.</p> required <p>Returns:</p> Type Description <code>list[Self]</code> <p>list[Self]: Unique citations with their counts.</p> Source code in <code>citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef from_source(cls, text: str) -&gt; list[Self]:\n\"\"\"Computes mentions of `counted_dockets()` vis-a-vis `counted_reports()` and\n    count the number of unique items, taking into account the Citation\n    structure and the use of __eq__ re: what is considered unique.\n    Examples:\n        &gt;&gt;&gt; source = \"374 Phil. 1, 10-11 (1999) 1111 SCRA 1111; G.R. No. 147033, April 30, 2003; G.R. No. 147033, April 30, 2003, 374 Phil. 1, 600; ABC v. XYZ, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449;  XXX, G.R. No. 31711, Sept. 30, 1971, 35 SCRA 190; Hello World, 1111 SCRA 1111; Y v. Z, 35 SCRA 190; 1 Off. Gaz. 41 Bar Matter No. 803, Jan. 1, 2000 Bar Matter No. 411, Feb. 1, 2000 Bar Matter No. 412, Jan. 1, 2000, 1111 SCRA 1111; 374 Phil. 1\"\n        &gt;&gt;&gt; list(CountedCitation.from_source(source))\n        [BM No. 412, Jan 01, 2000, 1111 SCRA 1111: 3, GR No. 147033, Apr 30, 2003, 374 Phil. 1: 3, GR No. 138570, Oct 10, 2000, 342 SCRA 449: 1, GR No. 31711, Sep 30, 1971, 35 SCRA 190: 2, 1 Off. Gaz. 41: 1]\n    Args:\n        text (str): Text to Evaluate.\n    Returns:\n        list[Self]: Unique citations with their counts.\n    \"\"\"  # noqa: E501\nall_reports = cls.counted_reports(text)  # includes reports in docket_reports\ndocket_reports = cls.counted_docket_reports(text)\nfor report in all_reports:\nfor dr in docket_reports:\nif report == dr:  # uses Citation __eq__\nbalance = 0\nif report.mentions &gt; dr.mentions:\nbalance = report.mentions - dr.mentions\ndr.mentions = dr.mentions + balance\nreport.mentions = 0\nreturn docket_reports + [\nreport for report in all_reports if report.mentions &gt; 0\n]\n</code></pre>"},{"location":"citeable/","title":"Specific Types","text":""},{"location":"citeable/#docket-report-citation","title":"Docket Report Citation","text":"<p>         Bases: <code>Docket</code>, <code>Report</code>, <code>abc.ABC</code></p> <p>Note <code>Report</code> is defined in a separate library <code>citation-report</code>.</p> <p>The <code>DocketReportCitation</code> abstract class makes sure that all of the fields of a Docket object alongside all of the fields of a <code>Report</code> object will be utilized. It also mandates the implementation of a<code>cls.search()</code> method.</p> Source code in <code>citation_utils/dockets/models/docket_citation.py</code> Python<pre><code>class DocketReportCitation(Docket, Report, abc.ABC):\n\"\"\"Note `Report` is defined in a separate library `citation-report`.\n    The `DocketReportCitation` abstract class makes sure that all of the\n    fields of a [Docket][docket-model] object alongside all of the fields of a `Report`\n    object will be utilized. It also mandates the implementation of a`cls.search()`\n    method.\n    \"\"\"\n@property\ndef _docket(self):\nif self.first_id:\nreturn f\"{self.category.name} No. {self.serial_text}, {self.formatted_date}\"\nelif self.ids:\nreturn f\"{self.category.name} No. {self.ids}, {self.formatted_date}\"\nreturn None\n@property\ndef _report(self):\nreturn self.volpubpage or None\ndef __str__(self) -&gt; str:\nif self._docket and self._report:\nreturn f\"{self._docket}, {self._report}\"\nelif self._docket:\nreturn self._docket\nelif self._report:\nreturn self._report\nreturn \"No citation.\"\ndef __repr__(self) -&gt; str:\nif self._docket and self._report:\nreturn f\"&lt;DocketReport: {self._docket} | {self._report}&gt;\"\nelif self._docket:\nreturn f\"&lt;DocketReport: {self._docket}&gt;\"\nelif self._report:\nreturn f\"&lt;DocketReport: {self._report}&gt;\"\nreturn \"&lt;DocketReport: improper citation&gt;\"\n@classmethod\n@abc.abstractmethod\ndef search(cls, raw: str) -&gt; Iterator[Self]:\nraise NotImplementedError(\"Search method must produce Iterator of instance.\")\n</code></pre>"},{"location":"citeable/#general-register","title":"General Register","text":"<p>         Bases: <code>DocketReportCitation</code></p> Source code in <code>citation_utils/dockets/constructed_gr.py</code> Python<pre><code>class CitationGR(DocketReportCitation):\n...\n@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `GR` docket pattern, inclusive of their optional Report object.\n        Examples:\n            &gt;&gt;&gt; text = \"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"\n            &gt;&gt;&gt; cite = next(CitationGR.search(text))\n            &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n            {'publisher': 'SCRA', 'volume': '342', 'page': '449', 'volpubpage': '342 SCRA 449', 'context': 'G.R. Nos. 138570, 138572, 138587, 138680, 138698', 'category': 'GR', 'ids': '138570, 138572, 138587, 138680, 138698', 'docket_date': datetime.date(2000, 10, 10)}\n        Args:\n            text (str): Text to look for citation objects\n        Yields:\n            Iterator[Self]: Combination of Docket and Report pydantic model.\n        \"\"\"  # noqa E501\nfor result in constructed_gr.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"citeable/#citation_utils.dockets.constructed_gr.CitationGR-functions","title":"Functions","text":""},{"location":"citeable/#citation_utils.dockets.constructed_gr.CitationGR.search","title":"<code>search(text)</code>  <code>classmethod</code>","text":"<p>Get all dockets matching the <code>GR</code> docket pattern, inclusive of their optional Report object.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"\n&gt;&gt;&gt; cite = next(CitationGR.search(text))\n&gt;&gt;&gt; cite.model_dump(exclude_none=True)\n{'publisher': 'SCRA', 'volume': '342', 'page': '449', 'volpubpage': '342 SCRA 449', 'context': 'G.R. Nos. 138570, 138572, 138587, 138680, 138698', 'category': 'GR', 'ids': '138570, 138572, 138587, 138680, 138698', 'docket_date': datetime.date(2000, 10, 10)}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for citation objects</p> required <p>Yields:</p> Type Description <code>Self</code> <p>Iterator[Self]: Combination of Docket and Report pydantic model.</p> Source code in <code>citation_utils/dockets/constructed_gr.py</code> Python<pre><code>@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `GR` docket pattern, inclusive of their optional Report object.\n    Examples:\n        &gt;&gt;&gt; text = \"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"\n        &gt;&gt;&gt; cite = next(CitationGR.search(text))\n        &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n        {'publisher': 'SCRA', 'volume': '342', 'page': '449', 'volpubpage': '342 SCRA 449', 'context': 'G.R. Nos. 138570, 138572, 138587, 138680, 138698', 'category': 'GR', 'ids': '138570, 138572, 138587, 138680, 138698', 'docket_date': datetime.date(2000, 10, 10)}\n    Args:\n        text (str): Text to look for citation objects\n    Yields:\n        Iterator[Self]: Combination of Docket and Report pydantic model.\n    \"\"\"  # noqa E501\nfor result in constructed_gr.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"citeable/#administrative-matter","title":"Administrative Matter","text":"<p>         Bases: <code>DocketReportCitation</code></p> Source code in <code>citation_utils/dockets/constructed_am.py</code> Python<pre><code>class CitationAM(DocketReportCitation):\n...\n@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `AM` docket pattern, inclusive of their optional Report object.\n        Examples:\n            &gt;&gt;&gt; text = \"A.M. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n            &gt;&gt;&gt; cite = next(CitationAM.search(text))\n            &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n            {'publisher': 'SCRA', 'volume': '206', 'page': '491', 'volpubpage': '206 SCRA 491', 'context': 'A.M. No. P-88-198', 'category': 'AM', 'ids': 'P-88-198', 'docket_date': datetime.date(1992, 2, 25)}\n        Args:\n            text (str): Text to look for citation objects\n        Yields:\n            Iterator[Self]: Combination of Docket and Report pydantic model.\n        \"\"\"  # noqa E501\nfor result in constructed_am.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"citeable/#citation_utils.dockets.constructed_am.CitationAM-functions","title":"Functions","text":""},{"location":"citeable/#citation_utils.dockets.constructed_am.CitationAM.search","title":"<code>search(text)</code>  <code>classmethod</code>","text":"<p>Get all dockets matching the <code>AM</code> docket pattern, inclusive of their optional Report object.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"A.M. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n&gt;&gt;&gt; cite = next(CitationAM.search(text))\n&gt;&gt;&gt; cite.model_dump(exclude_none=True)\n{'publisher': 'SCRA', 'volume': '206', 'page': '491', 'volpubpage': '206 SCRA 491', 'context': 'A.M. No. P-88-198', 'category': 'AM', 'ids': 'P-88-198', 'docket_date': datetime.date(1992, 2, 25)}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for citation objects</p> required <p>Yields:</p> Type Description <code>Self</code> <p>Iterator[Self]: Combination of Docket and Report pydantic model.</p> Source code in <code>citation_utils/dockets/constructed_am.py</code> Python<pre><code>@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `AM` docket pattern, inclusive of their optional Report object.\n    Examples:\n        &gt;&gt;&gt; text = \"A.M. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n        &gt;&gt;&gt; cite = next(CitationAM.search(text))\n        &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n        {'publisher': 'SCRA', 'volume': '206', 'page': '491', 'volpubpage': '206 SCRA 491', 'context': 'A.M. No. P-88-198', 'category': 'AM', 'ids': 'P-88-198', 'docket_date': datetime.date(1992, 2, 25)}\n    Args:\n        text (str): Text to look for citation objects\n    Yields:\n        Iterator[Self]: Combination of Docket and Report pydantic model.\n    \"\"\"  # noqa E501\nfor result in constructed_am.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"citeable/#administrative-case","title":"Administrative Case","text":"<p>         Bases: <code>DocketReportCitation</code></p> Source code in <code>citation_utils/dockets/constructed_ac.py</code> Python<pre><code>class CitationAC(DocketReportCitation):\n...\n@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `AC` docket pattern, inclusive of their optional Report object.\n        Examples:\n            &gt;&gt;&gt; text = \"A.C. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n            &gt;&gt;&gt; cite = next(CitationAC.search(text))\n            &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n            {'publisher': 'SCRA', 'volume': '206', 'page': '491', 'volpubpage': '206 SCRA 491', 'context': 'A.C. No. P-88-198', 'category': 'AC', 'ids': 'P-88-198', 'docket_date': datetime.date(1992, 2, 25)}\n        Args:\n            text (str): Text to look for citation objects\n        Yields:\n            Iterator[Self]: Combination of Docket and Report pydantic model.\n        \"\"\"  # noqa E501\nfor result in constructed_ac.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"citeable/#citation_utils.dockets.constructed_ac.CitationAC-functions","title":"Functions","text":""},{"location":"citeable/#citation_utils.dockets.constructed_ac.CitationAC.search","title":"<code>search(text)</code>  <code>classmethod</code>","text":"<p>Get all dockets matching the <code>AC</code> docket pattern, inclusive of their optional Report object.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"A.C. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n&gt;&gt;&gt; cite = next(CitationAC.search(text))\n&gt;&gt;&gt; cite.model_dump(exclude_none=True)\n{'publisher': 'SCRA', 'volume': '206', 'page': '491', 'volpubpage': '206 SCRA 491', 'context': 'A.C. No. P-88-198', 'category': 'AC', 'ids': 'P-88-198', 'docket_date': datetime.date(1992, 2, 25)}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for citation objects</p> required <p>Yields:</p> Type Description <code>Self</code> <p>Iterator[Self]: Combination of Docket and Report pydantic model.</p> Source code in <code>citation_utils/dockets/constructed_ac.py</code> Python<pre><code>@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `AC` docket pattern, inclusive of their optional Report object.\n    Examples:\n        &gt;&gt;&gt; text = \"A.C. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n        &gt;&gt;&gt; cite = next(CitationAC.search(text))\n        &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n        {'publisher': 'SCRA', 'volume': '206', 'page': '491', 'volpubpage': '206 SCRA 491', 'context': 'A.C. No. P-88-198', 'category': 'AC', 'ids': 'P-88-198', 'docket_date': datetime.date(1992, 2, 25)}\n    Args:\n        text (str): Text to look for citation objects\n    Yields:\n        Iterator[Self]: Combination of Docket and Report pydantic model.\n    \"\"\"  # noqa E501\nfor result in constructed_ac.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"citeable/#bar-matter","title":"Bar Matter","text":"<p>         Bases: <code>DocketReportCitation</code></p> Source code in <code>citation_utils/dockets/constructed_bm.py</code> Python<pre><code>class CitationBM(DocketReportCitation):\n...\n@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `BM` docket pattern, inclusive of their optional Report object.\n        Examples:\n            &gt;&gt;&gt; text = \"B.M. No. 1678, December 17, 2007\"\n            &gt;&gt;&gt; cite = next(CitationBM.search(text))\n            &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n            {'context': 'B.M. No. 1678', 'category': 'BM', 'ids': '1678', 'docket_date': datetime.date(2007, 12, 17)}\n        Args:\n            text (str): Text to look for citation objects\n        Yields:\n            Iterator[Self]: Combination of Docket and Report pydantic model.\n        \"\"\"  # noqa E501\nfor result in constructed_bm.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"citeable/#citation_utils.dockets.constructed_bm.CitationBM-functions","title":"Functions","text":""},{"location":"citeable/#citation_utils.dockets.constructed_bm.CitationBM.search","title":"<code>search(text)</code>  <code>classmethod</code>","text":"<p>Get all dockets matching the <code>BM</code> docket pattern, inclusive of their optional Report object.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"B.M. No. 1678, December 17, 2007\"\n&gt;&gt;&gt; cite = next(CitationBM.search(text))\n&gt;&gt;&gt; cite.model_dump(exclude_none=True)\n{'context': 'B.M. No. 1678', 'category': 'BM', 'ids': '1678', 'docket_date': datetime.date(2007, 12, 17)}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for citation objects</p> required <p>Yields:</p> Type Description <code>Self</code> <p>Iterator[Self]: Combination of Docket and Report pydantic model.</p> Source code in <code>citation_utils/dockets/constructed_bm.py</code> Python<pre><code>@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Get all dockets matching the `BM` docket pattern, inclusive of their optional Report object.\n    Examples:\n        &gt;&gt;&gt; text = \"B.M. No. 1678, December 17, 2007\"\n        &gt;&gt;&gt; cite = next(CitationBM.search(text))\n        &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n        {'context': 'B.M. No. 1678', 'category': 'BM', 'ids': '1678', 'docket_date': datetime.date(2007, 12, 17)}\n    Args:\n        text (str): Text to look for citation objects\n    Yields:\n        Iterator[Self]: Combination of Docket and Report pydantic model.\n    \"\"\"  # noqa E501\nfor result in constructed_bm.detect(text):\nyield cls(**result)\n</code></pre>"},{"location":"sqlite/","title":"sqlite analysis","text":"<p>Assume you're able to collect citations and place them into a database with the fields previously established:</p>"},{"location":"sqlite/#multiple-category-and-serial-having-the-same-values","title":"Multiple category and serial having the same values","text":"<p>This state is valid but should result in connected decisions, e.g. a motion for reconsideration resolves an earlier decided case. This is the reason that a citation needs a <code>docket date</code> to distinguish connected cases.</p> <p>Consider for instance the following query:</p> SQL<pre><code>select\ndocket_category, docket_serial, docket_date\nfrom\nvalid\nwhere\ndocket_category = \"GR\"\nand docket_serial = '109645'\norder by docket_date desc\n</code></pre> <p>Yielding the connected Ortigas decision rows which can be considered a collection of related cases:</p> <ol> <li>[\"GR\",\"109645\",\"2015-01-21\"]</li> <li>[\"GR\",\"109645\",\"1997-08-15\"]</li> <li>[\"GR\",\"109645\",\"1996-03-04\"]</li> <li>[\"GR\",\"109645\",\"1994-07-25\"]</li> </ol> <p>Typographic errors in these category and serial pairings, therefore, result in an unconnected case being considered a part of an ostensible collection. The following query is one way to check for an unconnected case being improperly included:</p> SQL<pre><code>select\ncount(docket_date) num,\ndocket_category,\ndocket_serial,\nmin(docket_date) earliest,\nmax(docket_date) latest,\nmax(docket_date) - min(docket_date) diff, -- large difference is indicative of impropriety in at least one category / serial pair\njson_group_array(docket_date) dates,\njson_group_array(origin) origins,\njson_group_array(title) titles\nfrom\nvalid\nwhere\ndocket_date is not null\ngroup by\ndocket_category,\ndocket_serial\nhaving\nnum &gt;= 2\norder by\ndiff desc, num desc\n</code></pre>"},{"location":"sqlite/#inconsistent-naming-convention-re-am-sc","title":"Inconsistent naming convention re: AM -SC","text":"<p>Originally thought that a suffixed <code>-SC</code> Administrative Matter meant that these were rule / statute patterns. After exploring the data, it appears that suffixed <code>-SC</code> AMs are also citation patterns for decisions, making it difficult to classify. To categorize the rules better, it may be useful to initially get the list of AMs as citation patterns and make statutory AMs an exclusive enumeration.</p> SQL<pre><code>select\ntitle, docket_category, docket_serial, docket_date\nfrom\nvalid\nwhere\ndocket_category = \"AM\"\nand docket_serial like '%-sc'\norder by docket_date desc\n</code></pre>"},{"location":"sqlite/#invalid-citation-patterns","title":"Invalid citation patterns","text":"SQL<pre><code>-- present GRs: 68 rows\nselect * from main.invalid where orig_idx like '%g r%' or orig_idx like '%g.r%' or orig_idx like '%gr%'\n-- admin matters: 50 rows\nselect * from main.invalid where orig_idx like '%a m%' or orig_idx like '%a.m%' or orig_idx like '%am%' or orig_idx like '%adm%m%'\n-- admin cases: 113 rows\nselect * from main.invalid where orig_idx like '%a c%' or orig_idx like '%a.c%' or orig_idx like '%ac%' or orig_idx like '%adm%c%'\n-- udks: 13 rows\nselect * from main.invalid where orig_idx like '%udk%'\n-- PET cases: 7 rows\nselect * from main.invalid where orig_idx like '%p.e.t%'\n-- too low char count: 65 rows\nselect * from main.invalid where length(orig_idx) &lt;= 7\n</code></pre>"},{"location":"sqlite/#impropriety-detector","title":"Impropriety detector","text":"SQL<pre><code>SELECT\nCOUNT(docket_date) num,\ndocket_category,\ndocket_serial,\nMIN(docket_date) earliest,\nMAX(docket_date) latest,\nMAX(docket_date) - MIN(docket_date) diff,\n-- large difference is indicative of impropriety in at least one category / serial pair\njson_group_array(docket_date) dates,\njson_group_array(origin) origins,\njson_group_array(title) titles\nFROM\nvalid\nWHERE\ndocket_date IS NOT NULL\nGROUP BY\ndocket_category,\ndocket_serial\nHAVING\nnum &gt;= 2\nORDER BY\ndiff DESC,\nnum DESC\n</code></pre>"},{"location":"structure/","title":"API","text":""},{"location":"structure/#citabledocument","title":"CitableDocument","text":"<p>A <code>Citation</code>'s <code>extract_citations()</code> function relies on a <code>CitableDocument</code>.</p> <p>Creates three main reusable lists:</p> list concept <code>@docketed_reports</code> list of <code>DocketReportCitation</code> found in the text, excluding exceptional statutory dockets <code>@reports</code> list of <code>Report</code> found in the text (which may already be included in <code>@docketed_reports</code>) <code>@undocketed_reports</code> = <code>@docketed_reports</code> - <code>@reports</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text_statutes = \"Bar Matter No. 803, Jan. 1, 2000; Bar Matter No. 411, Feb. 1, 2000\"\n&gt;&gt;&gt; len(CitableDocument(text=text_statutes).docketed_reports) # no citations, since these are 'statutory dockets'\n0\n&gt;&gt;&gt; text_cites = \"374 Phil. 1, 10-11 (1999) 1111 SCRA 1111; G.R. No. 147033, April 30, 2003; G.R. No. 147033, April 30, 2003, 374 Phil. 1, 600; ABC v. XYZ, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449;  XXX, G.R. No. 31711, Sept. 30, 1971, 35 SCRA 190; Hello World, 1111 SCRA 1111; Y v. Z, 35 SCRA 190;\"\n&gt;&gt;&gt; doc1 = CitableDocument(text=text_cites)\n&gt;&gt;&gt; len(doc1.docketed_reports)\n4\n&gt;&gt;&gt; doc1.undocketed_reports\n{'1111 SCRA 1111'}\n&gt;&gt;&gt; text = \"&lt;em&gt;Gatchalian Promotions Talent Pool, Inc. v. Atty. Naldoza&lt;/em&gt;, 374 Phil. 1, 10-11 (1999), citing: &lt;em&gt;In re Almacen&lt;/em&gt;, 31 SCRA 562, 600 (1970).; People v. Umayam, G.R. No. 147033, April 30, 2003; &lt;i&gt;Bagong Alyansang Makabayan v. Zamora,&lt;/i&gt; G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449; Villegas &lt;em&gt;v.&lt;/em&gt; Subido, G.R. No. 31711, Sept. 30, 1971, 41 SCRA 190;\"\n&gt;&gt;&gt; doc2 = CitableDocument(text=text)\n&gt;&gt;&gt; set(doc2.get_citations()) == {'GR No. 147033, Apr. 30, 2003', 'GR No. 138570, Oct. 10, 2000, 342 SCRA 449', 'GR No. 31711, Sep. 30, 1971, 41 SCRA 190', '374 Phil. 1', '31 SCRA 562'}\nTrue\n</code></pre> Source code in <code>citation_utils/document.py</code> Python<pre><code>@dataclass\nclass CitableDocument:\n\"\"\"Creates three main reusable lists:\n    list | concept\n    :--:|:--:\n    `@docketed_reports` | list of `DocketReportCitation` found in the text, excluding exceptional statutory dockets\n    `@reports` | list of `Report` found in the text (which may already be included in `@docketed_reports`)\n    `@undocketed_reports` | = `@docketed_reports` - `@reports`\n    Examples:\n        &gt;&gt;&gt; text_statutes = \"Bar Matter No. 803, Jan. 1, 2000; Bar Matter No. 411, Feb. 1, 2000\"\n        &gt;&gt;&gt; len(CitableDocument(text=text_statutes).docketed_reports) # no citations, since these are 'statutory dockets'\n        0\n        &gt;&gt;&gt; text_cites = \"374 Phil. 1, 10-11 (1999) 1111 SCRA 1111; G.R. No. 147033, April 30, 2003; G.R. No. 147033, April 30, 2003, 374 Phil. 1, 600; ABC v. XYZ, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449;  XXX, G.R. No. 31711, Sept. 30, 1971, 35 SCRA 190; Hello World, 1111 SCRA 1111; Y v. Z, 35 SCRA 190;\"\n        &gt;&gt;&gt; doc1 = CitableDocument(text=text_cites)\n        &gt;&gt;&gt; len(doc1.docketed_reports)\n        4\n        &gt;&gt;&gt; doc1.undocketed_reports\n        {'1111 SCRA 1111'}\n        &gt;&gt;&gt; text = \"&lt;em&gt;Gatchalian Promotions Talent Pool, Inc. v. Atty. Naldoza&lt;/em&gt;, 374 Phil. 1, 10-11 (1999), citing: &lt;em&gt;In re Almacen&lt;/em&gt;, 31 SCRA 562, 600 (1970).; People v. Umayam, G.R. No. 147033, April 30, 2003; &lt;i&gt;Bagong Alyansang Makabayan v. Zamora,&lt;/i&gt; G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449; Villegas &lt;em&gt;v.&lt;/em&gt; Subido, G.R. No. 31711, Sept. 30, 1971, 41 SCRA 190;\"\n        &gt;&gt;&gt; doc2 = CitableDocument(text=text)\n        &gt;&gt;&gt; set(doc2.get_citations()) == {'GR No. 147033, Apr. 30, 2003', 'GR No. 138570, Oct. 10, 2000, 342 SCRA 449', 'GR No. 31711, Sep. 30, 1971, 41 SCRA 190', '374 Phil. 1', '31 SCRA 562'}\n        True\n    \"\"\"  # noqa: E501\ntext: str\ndef __post_init__(self):\nself.reports = list(Report.extract_reports(self.text))\nself.docketed_reports = list(self.get_docketed_reports(self.text))\nself.undocketed_reports = self.get_undocketed_reports()\n@classmethod\ndef get_docketed_reports(\ncls, text: str, exclude_docket_rules: bool = True\n) -&gt; Iterator[DocketReport]:\n\"\"\"Extract from `raw` text all raw citations which should include their `Docket` and `Report` component parts.\n        This may however include statutory rules since some docket categories like AM and BM use this convention.\n        To exclude statutory rules, a flag is included as a default.\n        Examples:\n            &gt;&gt;&gt; cite = next(CitableDocument.get_docketed_reports(\"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"))\n            &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n            {'publisher': 'SCRA', 'volume': '342', 'page': '449', 'volpubpage': '342 SCRA 449', 'context': 'G.R. Nos. 138570, 138572, 138587, 138680, 138698', 'category': 'GR', 'ids': '138570, 138572, 138587, 138680, 138698', 'docket_date': datetime.date(2000, 10, 10)}\n            &gt;&gt;&gt; statutory_text = \"Bar Matter No. 803, Jan. 1, 2000\"\n            &gt;&gt;&gt; next(CitableDocument.get_docketed_reports(statutory_text)) # default\n            Traceback (most recent call last):\n                ...\n            StopIteration\n        Args:\n            text (str): Text to look for `Dockets` and `Reports`\n        Yields:\n            Iterator[DocketReport]: Any of custom `Docket` with `Report` types, e.g. `CitationAC`, etc.\n        \"\"\"  # noqa: E501\nfor search_func in (\nCitationAC.search,\nCitationAM.search,\nCitationOCA.search,\nCitationBM.search,\nCitationGR.search,\nCitationPET.search,\nCitationUDK.search,\nCitationJIB.search,\n):\n# Each search function is applied to the text, each match yielded\nfor result in search_func(text):\nif exclude_docket_rules:\nif is_statutory_rule(result):\ncontinue\nyield result\ndef get_undocketed_reports(self):\n\"\"\"Steps:\n        1. From a set of `uniq_reports` (see `self.reports`);\n        2. Compare to reports found in `@docketed_reports`\n        3. Limit reports to those _without_ an accompaying docket\n        \"\"\"\nuniq_reports = set(Report.get_unique(self.text))\nfor cite in self.docketed_reports:\nif cite.volpubpage in uniq_reports:\nuniq_reports.remove(cite.volpubpage)\nreturn uniq_reports\ndef get_citations(self) -&gt; Iterator[str]:\n\"\"\"There are two main lists to evaluate:\n        1. `@docketed_reports` - each includes a `Docket` (optionally attached to a `Report`)\n        2. `@reports` - from the same text, just get `Report` objects.\n        Can filter out `Report` objects not docketed and thus return\n        a more succinct citation list which includes both constructs mentioned above but\n        without duplicate `reports`.\n        \"\"\"  # noqa: E501\nif self.docketed_reports:\nfor doc_report_cite in self.docketed_reports:\nyield str(doc_report_cite)\nif self.undocketed_reports:\nyield from self.undocketed_reports  # already &lt;str&gt;\nelse:\nif self.reports:\nfor report in self.reports:\nyield str(report)\n</code></pre>"},{"location":"structure/#citation_utils.CitableDocument-functions","title":"Functions","text":""},{"location":"structure/#citation_utils.document.CitableDocument.get_citations","title":"<code>get_citations()</code>","text":"<p>There are two main lists to evaluate:</p> <ol> <li><code>@docketed_reports</code> - each includes a <code>Docket</code> (optionally attached to a <code>Report</code>)</li> <li><code>@reports</code> - from the same text, just get <code>Report</code> objects.</li> </ol> <p>Can filter out <code>Report</code> objects not docketed and thus return a more succinct citation list which includes both constructs mentioned above but without duplicate <code>reports</code>.</p> Source code in <code>citation_utils/document.py</code> Python<pre><code>def get_citations(self) -&gt; Iterator[str]:\n\"\"\"There are two main lists to evaluate:\n    1. `@docketed_reports` - each includes a `Docket` (optionally attached to a `Report`)\n    2. `@reports` - from the same text, just get `Report` objects.\n    Can filter out `Report` objects not docketed and thus return\n    a more succinct citation list which includes both constructs mentioned above but\n    without duplicate `reports`.\n    \"\"\"  # noqa: E501\nif self.docketed_reports:\nfor doc_report_cite in self.docketed_reports:\nyield str(doc_report_cite)\nif self.undocketed_reports:\nyield from self.undocketed_reports  # already &lt;str&gt;\nelse:\nif self.reports:\nfor report in self.reports:\nyield str(report)\n</code></pre>"},{"location":"structure/#citation_utils.document.CitableDocument.get_docketed_reports","title":"<code>get_docketed_reports(text, exclude_docket_rules=True)</code>  <code>classmethod</code>","text":"<p>Extract from <code>raw</code> text all raw citations which should include their <code>Docket</code> and <code>Report</code> component parts. This may however include statutory rules since some docket categories like AM and BM use this convention. To exclude statutory rules, a flag is included as a default.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; cite = next(CitableDocument.get_docketed_reports(\"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"))\n&gt;&gt;&gt; cite.model_dump(exclude_none=True)\n{'publisher': 'SCRA', 'volume': '342', 'page': '449', 'volpubpage': '342 SCRA 449', 'context': 'G.R. Nos. 138570, 138572, 138587, 138680, 138698', 'category': 'GR', 'ids': '138570, 138572, 138587, 138680, 138698', 'docket_date': datetime.date(2000, 10, 10)}\n&gt;&gt;&gt; statutory_text = \"Bar Matter No. 803, Jan. 1, 2000\"\n&gt;&gt;&gt; next(CitableDocument.get_docketed_reports(statutory_text)) # default\nTraceback (most recent call last):\n...\nStopIteration\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for <code>Dockets</code> and <code>Reports</code></p> required <p>Yields:</p> Type Description <code>DocketReport</code> <p>Iterator[DocketReport]: Any of custom <code>Docket</code> with <code>Report</code> types, e.g. <code>CitationAC</code>, etc.</p> Source code in <code>citation_utils/document.py</code> Python<pre><code>@classmethod\ndef get_docketed_reports(\ncls, text: str, exclude_docket_rules: bool = True\n) -&gt; Iterator[DocketReport]:\n\"\"\"Extract from `raw` text all raw citations which should include their `Docket` and `Report` component parts.\n    This may however include statutory rules since some docket categories like AM and BM use this convention.\n    To exclude statutory rules, a flag is included as a default.\n    Examples:\n        &gt;&gt;&gt; cite = next(CitableDocument.get_docketed_reports(\"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"))\n        &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n        {'publisher': 'SCRA', 'volume': '342', 'page': '449', 'volpubpage': '342 SCRA 449', 'context': 'G.R. Nos. 138570, 138572, 138587, 138680, 138698', 'category': 'GR', 'ids': '138570, 138572, 138587, 138680, 138698', 'docket_date': datetime.date(2000, 10, 10)}\n        &gt;&gt;&gt; statutory_text = \"Bar Matter No. 803, Jan. 1, 2000\"\n        &gt;&gt;&gt; next(CitableDocument.get_docketed_reports(statutory_text)) # default\n        Traceback (most recent call last):\n            ...\n        StopIteration\n    Args:\n        text (str): Text to look for `Dockets` and `Reports`\n    Yields:\n        Iterator[DocketReport]: Any of custom `Docket` with `Report` types, e.g. `CitationAC`, etc.\n    \"\"\"  # noqa: E501\nfor search_func in (\nCitationAC.search,\nCitationAM.search,\nCitationOCA.search,\nCitationBM.search,\nCitationGR.search,\nCitationPET.search,\nCitationUDK.search,\nCitationJIB.search,\n):\n# Each search function is applied to the text, each match yielded\nfor result in search_func(text):\nif exclude_docket_rules:\nif is_statutory_rule(result):\ncontinue\nyield result\n</code></pre>"},{"location":"structure/#citation_utils.document.CitableDocument.get_undocketed_reports","title":"<code>get_undocketed_reports()</code>","text":"<p>Steps:</p> <ol> <li>From a set of <code>uniq_reports</code> (see <code>self.reports</code>);</li> <li>Compare to reports found in <code>@docketed_reports</code></li> <li>Limit reports to those without an accompaying docket</li> </ol> Source code in <code>citation_utils/document.py</code> Python<pre><code>def get_undocketed_reports(self):\n\"\"\"Steps:\n    1. From a set of `uniq_reports` (see `self.reports`);\n    2. Compare to reports found in `@docketed_reports`\n    3. Limit reports to those _without_ an accompaying docket\n    \"\"\"\nuniq_reports = set(Report.get_unique(self.text))\nfor cite in self.docketed_reports:\nif cite.volpubpage in uniq_reports:\nuniq_reports.remove(cite.volpubpage)\nreturn uniq_reports\n</code></pre>"},{"location":"structure/#docket-model","title":"Docket Model","text":"<p>         Bases: <code>BaseModel</code></p> <p>The Docket is the modern identifier of a Supreme Court decision.</p> <p>It is based on a <code>category</code>, a <code>serial id</code>, and a <code>date</code>.</p> Field Type Description <code>context</code> optional (str) Full texted matched by the regex pattern <code>category</code> optional (DocketCategory) See docket-category-model <code>ids</code> optional (str) The serial number of the docket category <code>docket_date</code> optional (date) The date associated with the docket Sample Citation Category Serial Date G.R. Nos. 138570, October 10, 2000 GR 74910 October 10, 2000 A.M. RTJ-12-2317 (Formerly OCA I.P.I. No. 10-3378-RTJ), Jan 1, 2000 AM RTJ-12-2317 Jan 1, 2000 A.C. No. 10179 (Formerly CBD 11-2985), March 04, 2014 AC 10179 Mar. 4, 2014 <p>The Docket is often paired with a Report, which is the traditional identifier based on volume and page numbers.</p> Source code in <code>citation_utils/dockets/models/docket_model.py</code> Python<pre><code>class Docket(BaseModel):\n\"\"\"\n    The Docket is the modern identifier of a Supreme Court decision.\n    It is based on a `category`, a `serial id`, and a `date`.\n    Field | Type | Description\n    --:|:--:|:--\n    `context` | optional (str) | Full texted matched by the regex pattern\n    `category` | optional (DocketCategory) | See [docket-category-model][]\n    `ids` | optional (str) | The serial number of the docket category\n    `docket_date` | optional (date) | The date associated with the docket\n    Sample Citation | Category | Serial | Date\n    :-- |:--:|:--:|:--:\n    _G.R. Nos. 138570, October 10, 2000_ | GR | 74910 | October 10, 2000\n    _A.M. RTJ-12-2317 (Formerly OCA I.P.I. No. 10-3378-RTJ), Jan 1, 2000_ | AM | RTJ-12-2317 |Jan 1, 2000\n    _A.C. No. 10179 (Formerly CBD 11-2985), March 04, 2014_ | AC | 10179 | Mar. 4, 2014\n    The Docket is often paired with a Report, which is the traditional\n    identifier based on volume and page numbers.\n    \"\"\"  # noqa: E501\nmodel_config = ConfigDict(use_enum_values=True)\ncontext: str = Field(..., description=\"Full text matched by regex pattern.\")\ncategory: DocketCategory = Field(..., description=\"e.g. General Register, etc.\")\nids: str = Field(..., description=\"Ok for a csv token, e.g. '24141, 14234, 12'\")\ndocket_date: date = Field(..., description=\"Either in UK, US styles\")\ndef __repr__(self) -&gt; str:\nreturn f\"&lt;Docket: {self.category} {self.serial_text}, {self.formatted_date}&gt;\"\ndef __str__(self) -&gt; str:\nif self.serial_text:\nreturn f\"{self.category} {self.serial_text}, {self.formatted_date}\"\nreturn \"No proper string detected.\"\ndef __eq__(self, other: Self) -&gt; bool:\nopt_1 = is_eq(self.category.name, other.category.name)\nopt_2 = is_eq(self.first_id, other.first_id)\nopt_3 = is_eq(self.docket_date.isoformat(), other.docket_date.isoformat())\nreturn all([opt_1, opt_2, opt_3])\n@property\ndef serial_text(self) -&gt; str:\n\"\"\"From raw `ids`, get the `cleaned_ids`, and of these `cleaned_ids`,\n            extract the `@first_id` found to deal with compound ids, e.g.\n            ids separated by 'and' and ','\n        Returns:\n            str: Singular text identifier\n        \"\"\"\nif x := self.first_id or self.ids:\nif adjust := gr_prefix_clean(x):\nreturn adjust\nreturn x\n@property\ndef first_id(self) -&gt; str:\n\"\"\"Get first bit from list of separated ids, when possible.\n        Returns:\n            str: First id found\n        \"\"\"\ndef first_exists(char: str, text: str):\n\"\"\"If a `char` exists in the `text`, split on this value.\"\"\"\nreturn text.split(char)[0] if char in text else None\nfor char in [\"/\", \",\", \";\", \" and \", \" AND \", \"&amp;\"]:\nif res := first_exists(char, self.ids):\nreturn res\nreturn self.ids\n@property\ndef formatted_date(self) -&gt; str | None:\nif self.docket_date:\nreturn self.docket_date.strftime(DOCKET_DATE_FORMAT)\nreturn None\n</code></pre>"},{"location":"structure/#citation_utils.dockets.Docket-attributes","title":"Attributes","text":""},{"location":"structure/#citation_utils.dockets.models.docket_model.Docket.first_id","title":"<code>first_id: str</code>  <code>property</code>","text":"<p>Get first bit from list of separated ids, when possible.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>First id found</p>"},{"location":"structure/#citation_utils.dockets.models.docket_model.Docket.serial_text","title":"<code>serial_text: str</code>  <code>property</code>","text":"<p>From raw <code>ids</code>, get the <code>cleaned_ids</code>, and of these <code>cleaned_ids</code>,     extract the <code>@first_id</code> found to deal with compound ids, e.g.     ids separated by 'and' and ','</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Singular text identifier</p>"},{"location":"structure/#docket-category","title":"Docket Category","text":""},{"location":"structure/#docket-category-model","title":"Docket Category Model","text":"<p>         Bases: <code>StrEnum</code></p> <p>Common docket references involving Philippine Supreme Court decisions.</p> Name Value <code>GR</code> General Register <code>AM</code> Administrative Matter <code>AC</code> Administrative Case <code>BM</code> Bar Matter <code>PET</code> Presidential Electoral Tribunal <code>OCA</code> Office of the Court Administrator <code>JIB</code> Judicial Integrity Board <code>UDK</code> Undocketed <p>Complication: These categories do not always represent decisions. For instance, there are are <code>AM</code> and <code>BM</code> docket numbers that represent rules rather than decisions.</p> Source code in <code>citation_utils/dockets/models/docket_category.py</code> Python<pre><code>class DocketCategory(StrEnum):\n\"\"\"Common docket references involving Philippine Supreme Court decisions.\n    Name | Value\n    :--|:--\n    `GR` | General Register\n    `AM` | Administrative Matter\n    `AC` | Administrative Case\n    `BM` | Bar Matter\n    `PET` | Presidential Electoral Tribunal\n    `OCA` | Office of the Court Administrator\n    `JIB` | Judicial Integrity Board\n    `UDK` | Undocketed\n    Complication: These categories do not always represent decisions. For instance,\n    there are are `AM` and `BM` docket numbers that represent rules rather\n    than decisions.\n    \"\"\"\nGR = \"General Register\"\nAM = \"Administrative Matter\"\nAC = \"Administrative Case\"\nBM = \"Bar Matter\"\nPET = \"Presidential Electoral Tribunal\"\nOCA = \"Office of the Court Administrator\"\nJIB = \"Judicial Integrity Board\"\nUDK = \"Undocketed\"\ndef __str__(self):\nreturn self.name\ndef __repr__(self) -&gt; str:\n\"\"\"Uses name of member `gr` instead of Enum default\n        `&lt;DocketCategory.GR: 'General Register'&gt;`. It becomes to\n        use the following conventions:\n        Examples:\n            &gt;&gt;&gt; DocketCategory['GR']\n            'GR'\n            &gt;&gt;&gt; DocketCategory.GR\n            'GR'\n        Returns:\n            str: The value of the Enum name\n        \"\"\"\nreturn str.__repr__(self.name.upper())\n</code></pre>"},{"location":"structure/#citation_utils.dockets.DocketCategory-functions","title":"Functions","text":""},{"location":"structure/#citation_utils.dockets.models.docket_category.DocketCategory.__repr__","title":"<code>__repr__()</code>","text":"<p>Uses name of member <code>gr</code> instead of Enum default <code>&lt;DocketCategory.GR: 'General Register'&gt;</code>. It becomes to use the following conventions:</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; DocketCategory['GR']\n'GR'\n&gt;&gt;&gt; DocketCategory.GR\n'GR'\n</code></pre> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The value of the Enum name</p> Source code in <code>citation_utils/dockets/models/docket_category.py</code> Python<pre><code>def __repr__(self) -&gt; str:\n\"\"\"Uses name of member `gr` instead of Enum default\n    `&lt;DocketCategory.GR: 'General Register'&gt;`. It becomes to\n    use the following conventions:\n    Examples:\n        &gt;&gt;&gt; DocketCategory['GR']\n        'GR'\n        &gt;&gt;&gt; DocketCategory.GR\n        'GR'\n    Returns:\n        str: The value of the Enum name\n    \"\"\"\nreturn str.__repr__(self.name.upper())\n</code></pre>"},{"location":"structure/#docket-citationconstructor","title":"Docket CitationConstructor","text":"<p>Although the different category docket models share a similar configuration, the regex strings involved are different for each, prompting the need for a preparatory constructor class:</p> <p>         Bases: <code>BaseModel</code></p> <p>Prefatorily, regex strings are defined so that a <code>re.Pattern</code> object can take advantage of the \"group_name\" assigned in the string.</p> <p>These are the docket styles with regex strings predefined:</p> <ol> <li>General Register</li> <li>Administrative Matter</li> <li>Administrative Case</li> <li>Bar Matter</li> <li>Office of the Court Administrator</li> <li>Presidential Electoral Tribunal</li> <li>Judicial Integrity Board</li> <li>Undocketed Case</li> </ol> <p>The CitationConstructor formalizes the assigned group names into their respective fields.</p> <p>Relatedly, it takes advantage of the <code>citation_date</code> and the <code>citation_report</code> libraries in generating the main <code>@pattern</code> since the regex strings above are only concerned with the <code>key</code> <code>num</code> <code>id</code> formula part of the docket, e.g. <code>GR</code> <code>No.</code> <code>123</code>... but not the accompanying date and report.</p> Source code in <code>citation_utils/dockets/models/constructor.py</code> Python<pre><code>class CitationConstructor(BaseModel):\n\"\"\"Prefatorily, regex strings are defined so that a\n    `re.Pattern` object can take advantage of the \"group_name\"\n    assigned in the string.\n    These are the docket styles with regex strings predefined:\n    1. General Register\n    2. Administrative Matter\n    3. Administrative Case\n    4. Bar Matter\n    5. Office of the Court Administrator\n    6. Presidential Electoral Tribunal\n    7. Judicial Integrity Board\n    8. Undocketed Case\n    The CitationConstructor formalizes the assigned group names into\n    their respective fields.\n    Relatedly, it takes advantage of\n    the `citation_date` and the `citation_report` libraries in\n    generating the main `@pattern` since the regex strings above\n    are only concerned with the `key` `num` `id` formula part\n    of the docket, e.g. `GR` `No.` `123`... but not the accompanying\n    date and report.\n    \"\"\"\nlabel: str = Field(\n...,\ntitle=\"Docket Label\",\ndescription=\"e.g. General Register, Administrative Matter\",\n)\nshort_category: str = Field(\n..., title=\"Docket Category Shorthand\", description=\"e.g. GR, AM\"\n)\ngroup_name: str = Field(\n...,\ntitle=\"Regex Group Name\",\ndescription=(\n\"e.g. 'gr_test_phrase' identifies that portion of the\"\n\"Match object that should be associated with the label.\"\n),\n)\ninit_name: str = Field(\n...,\ntitle=\"Regex Initial Group Name\",\ndescription=\"e.g. gr_mid, am_init; see .regexes for other group names\",\n)\ndocket_regex: str = Field(\n...,\ntitle=\"Regex Expression Proper\",\ndescription=(\n\"The full regex expression which includes the groupnames referred to above.\"\n),\n)\nkey_regex: str = Field(\n...,\ntitle=\"Regex Key\",\ndescription=\"Regex portion to get the serial ids\",\n)\nnum_regex: str = Field(\n...,\ntitle=\"Regex Num\",\ndescription=\"Regex portion for the num keyword to get the serial ids\",\n)\n@property\ndef pattern(self) -&gt; re.Pattern:\n\"\"\"Construct the regex string and generate a full Pattern object from:\n        1. `docket_regex`,\n        2. `docket_date` defined in the citation-date library\n        3. an optional `REPORT_REGEX` defined in the citation-report library\n        Returns:\n            Pattern: Combination of Docket and Report styles.\n        \"\"\"\nreturn re.compile(\n\"\".join(\n[\nrf\"{self.docket_regex}\",\nrf\"(?P&lt;extra_phrase&gt;{formerly}?{pp}?){DOCKET_DATE_REGEX}\",\nrf\"(?P&lt;opt_report&gt;\\,\\s*{REPORT_REGEX})?\",\n]\n),\nre.I | re.X,\n)\n@property\ndef key_num_pattern(self) -&gt; re.Pattern:\n\"\"\"Unlike full @pattern, this regex compiled object is limited to\n        just the key and number elements, e.g. \"GR No. 123\" or \"BP Blg. 45\"\n        \"\"\"\nregex = rf\"{self.key_regex}({self.num_regex})?\"\nreturn re.compile(regex, re.I | re.X)\ndef detect(self, raw: str) -&gt; Iterator[dict[str, Any]]:\n\"\"\"Logic: if `self.init_name` Match group exists, get entire\n        regex based on `self.group_name`, extract subgroups which will\n        consist of `Docket` and `Report` parts.\n        Args:\n            raw (str): Text to evaluate\n        Yields:\n            Iterator[dict[str, Any]]: A dict that can fill up a Docket + Report pydantic BaseModel\n        \"\"\"  # noqa: E501\nfor match in self.pattern.finditer(raw):\nif match.group(self.init_name):\nif ctx := match.group(self.group_name).strip(\", \"):\nraw_id = cull_extra(self.key_num_pattern.sub(\"\", ctx))\nids = raw_id.strip(\"()[] .,;\")\nraw_date = match.group(\"docket_date\")\ndate_found = decode_date(raw_date, True)\nif ids and date_found:\nyield dict(\ncontext=ctx,\nshort_category=self.short_category,\ncategory=self.label,\nids=ids,\ndocket_date=date_found,\npublisher=get_publisher_label(match),\nvolpubpage=match.group(\"volpubpage\"),\nvolume=match.group(\"volume\"),\npage=match.group(\"page\"),\n)\n</code></pre>"},{"location":"structure/#citation_utils.dockets.models.CitationConstructor-attributes","title":"Attributes","text":""},{"location":"structure/#citation_utils.dockets.models.constructor.CitationConstructor.key_num_pattern","title":"<code>key_num_pattern: re.Pattern</code>  <code>property</code>","text":"<p>Unlike full @pattern, this regex compiled object is limited to just the key and number elements, e.g. \"GR No. 123\" or \"BP Blg. 45\"</p>"},{"location":"structure/#citation_utils.dockets.models.constructor.CitationConstructor.pattern","title":"<code>pattern: re.Pattern</code>  <code>property</code>","text":"<p>Construct the regex string and generate a full Pattern object from:</p> <ol> <li><code>docket_regex</code>,</li> <li><code>docket_date</code> defined in the citation-date library</li> <li>an optional <code>REPORT_REGEX</code> defined in the citation-report library</li> </ol> <p>Returns:</p> Name Type Description <code>Pattern</code> <code>re.Pattern</code> <p>Combination of Docket and Report styles.</p>"},{"location":"structure/#citation_utils.dockets.models.CitationConstructor-functions","title":"Functions","text":""},{"location":"structure/#citation_utils.dockets.models.constructor.CitationConstructor.detect","title":"<code>detect(raw)</code>","text":"<p>Logic: if <code>self.init_name</code> Match group exists, get entire regex based on <code>self.group_name</code>, extract subgroups which will consist of <code>Docket</code> and <code>Report</code> parts.</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>str</code> <p>Text to evaluate</p> required <p>Yields:</p> Type Description <code>dict[str, Any]</code> <p>Iterator[dict[str, Any]]: A dict that can fill up a Docket + Report pydantic BaseModel</p> Source code in <code>citation_utils/dockets/models/constructor.py</code> Python<pre><code>def detect(self, raw: str) -&gt; Iterator[dict[str, Any]]:\n\"\"\"Logic: if `self.init_name` Match group exists, get entire\n    regex based on `self.group_name`, extract subgroups which will\n    consist of `Docket` and `Report` parts.\n    Args:\n        raw (str): Text to evaluate\n    Yields:\n        Iterator[dict[str, Any]]: A dict that can fill up a Docket + Report pydantic BaseModel\n    \"\"\"  # noqa: E501\nfor match in self.pattern.finditer(raw):\nif match.group(self.init_name):\nif ctx := match.group(self.group_name).strip(\", \"):\nraw_id = cull_extra(self.key_num_pattern.sub(\"\", ctx))\nids = raw_id.strip(\"()[] .,;\")\nraw_date = match.group(\"docket_date\")\ndate_found = decode_date(raw_date, True)\nif ids and date_found:\nyield dict(\ncontext=ctx,\nshort_category=self.short_category,\ncategory=self.label,\nids=ids,\ndocket_date=date_found,\npublisher=get_publisher_label(match),\nvolpubpage=match.group(\"volpubpage\"),\nvolume=match.group(\"volume\"),\npage=match.group(\"page\"),\n)\n</code></pre>"}]}