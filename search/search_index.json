{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Overall strategy</p> <p>Like citation-reports, there is a problem involving inconsistent use of values citations. We address it the same way by dissecting the component parts and generating a uniform citation.</p> <p>The component parts of a Supreme Court decision citation:</p> <pre><code>flowchart TB\ncite(citation)---docket\ncite---report\ndocket---d1(docket category)\ndocket---d2(docket serial)\ndocket---d3(docket date)\nreport---r1(phil)\nreport---r2(scra)\nreport---r3(offg)</code></pre> <p>Sample citation, typically found in the body and the footnotes section of a decision:</p> <p>Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449</p> <p>Dissecting the above yields</p> case title docket category docket serial docket date report phil report scra report offg Bagong Alyansang... <code>gr</code> 138570 2000-10-10 - 342 SCRA 449 -"},{"location":"#citation","title":"Citation","text":"<p>The <code>Report</code> Model from citation-report is only one part of a Philippine Supreme Court citation. This library will handle the patterns involved with respect to the Docket, for the purpose of creating a Citation.</p> <p>               Bases: <code>BaseModel</code></p> <p>A Philippine Supreme Court <code>Citation</code> consists of:</p> <ol> <li><code>Docket</code> includes:<ol> <li>category,</li> <li>serial number, and</li> <li>date.</li> </ol> </li> <li><code>Report</code> - as defined in citation-report - includes:<ol> <li>volume number,</li> <li>identifying acronym of the reporter/publisher,</li> <li>page of the reported volume.</li> </ol> </li> </ol> <p>It is typical to see a <code>Docket</code> combined with a <code>Report</code>:</p> <p>Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449</p> <p>Taken together (and using Bagong Alyansang Makabayan as an example) the text above can be extracted into fields:</p> Example Field Type Description GR <code>docket_category</code> optional (<code>ShortDocketCategory</code>) See shorthand 138570 <code>docket_serial</code> optional (str) See serialized identifier datetime.date(2000, 10, 10) <code>docket_date</code> optional (date) When docket serial issued GR 138570, Oct. 10, 2000 <code>docket</code> optional (str) Combined <code>docket_category</code> <code>docket_serial</code> <code>docket_date</code> None <code>phil</code> optional (str) combined <code>volume</code> Phil. <code>page</code> 342 SCRA 449 <code>scra</code> optional (str) combined <code>volume</code> SCRA <code>page</code> None <code>offg</code> optional (str) combined <code>volume</code> O.G. <code>page</code> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>class Citation(BaseModel):\n    \"\"\"\n    A Philippine Supreme Court `Citation` consists of:\n\n    1. `Docket` includes:\n        1. _category_,\n        2. _serial number_, and\n        3. _date_.\n    2. `Report` - as defined in [citation-report](https://github.com/justmars/citation-report) - includes:\n        1. _volume number_,\n        2. _identifying acronym of the reporter/publisher_,\n        3. _page of the reported volume_.\n\n    It is typical to see a `Docket` combined with a `Report`:\n\n    &gt; _Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449_\n\n    Taken together (and using _Bagong Alyansang Makabayan_ as an example) the text above can be extracted into fields:\n\n    Example | Field | Type | Description\n    --:|:--:|:--|--:\n    GR | `docket_category` | optional (`ShortDocketCategory`) | See shorthand\n    138570 |`docket_serial` | optional (str) | See serialized identifier\n    datetime.date(2000, 10, 10) | `docket_date` | optional (date) | When docket serial issued\n    GR 138570, Oct. 10, 2000 | `docket` | optional (str) | Combined `docket_category` `docket_serial` `docket_date`\n    None | `phil` | optional (str) | combined `volume` Phil. `page`\n    342 SCRA 449 | `scra` | optional (str) | combined `volume` SCRA `page`\n    None | `offg` | optional (str) | combined `volume` O.G. `page`\n    \"\"\"  # noqa: E501\n\n    model_config = ConfigDict(str_strip_whitespace=True)\n    docket_category: DocketCategory | None = Field(default=None, alias=\"cat\")\n    docket_serial: str | None = Field(default=None, alias=\"num\")\n    docket_date: datetime.date | None = Field(default=None, alias=\"date\")\n    phil: str | None = Field(default=None)\n    scra: str | None = Field(default=None)\n    offg: str | None = Field(default=None)\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Citation: {str(self)}&gt;\"\n\n    def __str__(self) -&gt; str:\n        docket_str = self.get_docket_display()\n        report_str = self.phil or self.scra or self.offg\n        if docket_str and report_str:\n            return f\"{docket_str}, {report_str}\"\n        elif docket_str:\n            return f\"{docket_str}\"\n        elif report_str:\n            return f\"{report_str}\"\n        return f\"&lt;Bad citation str: {self.docket_category=} {self.docket_serial=} {self.docket_date=}&gt;\"  # noqa: E501\n\n    def __eq__(self, other: Self) -&gt; bool:\n        \"\"\"Helps `seen` variable in `CountedCitation`: either the docket bits match\n        or any of the report fields match.\"\"\"\n\n        def is_docket_match(other: Self) -&gt; bool:\n            \"\"\"All the docket elements must match to be equal.\"\"\"\n            cat_is_eq = (\n                self.docket_category is not None\n                and other.docket_category is not None\n                and (self.docket_category == other.docket_category)\n            )\n            num_is_eq = (\n                self.docket_serial is not None\n                and other.docket_serial is not None\n                and (self.docket_serial == other.docket_serial)\n            )\n            date_is_eq = (\n                self.docket_date is not None\n                and other.docket_date is not None\n                and (self.docket_date == other.docket_date)\n            )\n            return all([cat_is_eq, num_is_eq, date_is_eq])\n\n        if is_docket_match(other):\n            return True\n\n        return any(\n            [\n                self.scra and other.scra and self.scra.lower() == other.scra.lower(),\n                self.phil and other.phil and self.phil.lower() == other.phil.lower(),\n                self.offg and other.offg and self.offg.lower() == other.offg.lower(),\n            ]\n        )\n\n    @field_serializer(\"docket_date\")\n    def serialize_dt(self, value: datetime.date | None):\n        if value:\n            return value.isoformat()\n\n    @field_serializer(\"docket_serial\")\n    def serialize_num(self, value: str | None):\n        if value:\n            return Docket.clean_serial(value)\n\n    @field_serializer(\"docket_category\")\n    def serialize_cat(self, value: DocketCategory | None):\n        if value:\n            return value.name.lower()\n\n    @field_serializer(\"phil\")\n    def serialize_phil(self, value: str | None):\n        if value:\n            return value.lower()\n\n    @field_serializer(\"scra\")\n    def serialize_scra(self, value: str | None):\n        if value:\n            return value.lower()\n\n    @field_serializer(\"offg\")\n    def serialize_offg(self, value: str | None):\n        if value:\n            return value.lower()\n\n    @model_serializer\n    def ser_model(self) -&gt; dict[str, str | datetime.date | None]:\n        \"\"\"Generate a database row-friendly format of the model. Note the different\n        field names: `cat`, `num`, `dt`, `phil`, `scra`, `offg` map to either a usable\n        database value or `None`. The docket values here have the option to be `None`\n        since some citations, especially the legacy variants, do not include their\n        docket equivalents in the source texts.\n\n        Examples:\n            &gt;&gt;&gt; text = \"OCA IPI No. 10-3450-P, Feb. 06, 2008\"\n            &gt;&gt;&gt; cite = Citation.extract_citation(text)\n            &gt;&gt;&gt; cite.model_dump_json()\n            '{\"cat\":\"oca\",\"num\":\"10-3450-p\",\"date\":\"2008-02-06\",\"phil\":null,\"scra\":null,\"offg\":null}'\n\n        \"\"\"\n        return {\n            \"cat\": self.serialize_cat(self.docket_category),\n            \"num\": self.serialize_num(self.docket_serial),\n            \"date\": self.serialize_dt(self.docket_date),\n            \"phil\": self.serialize_phil(self.phil),\n            \"scra\": self.serialize_scra(self.scra),\n            \"offg\": self.serialize_offg(self.offg),\n        }\n\n    def set_slug(self) -&gt; str | None:\n        \"\"\"Create a unique identifier of a decision.\n\n        Examples:\n            &gt;&gt;&gt; text = \"GR 138570, Oct. 10, 2000\"\n            &gt;&gt;&gt; Citation.extract_citation(text).set_slug()\n            'gr-138570-2000-10-10'\n\n        \"\"\"\n        bits = [\n            self.serialize_cat(self.docket_category),\n            self.serialize_num(self.docket_serial),\n            self.serialize_dt(self.docket_date),\n        ]\n        if all(bits):\n            return \"-\".join(bits)  # type: ignore\n        return None\n\n    @classmethod\n    def get_docket_slug_from_text(cls, v: str) -&gt; str | None:\n        \"\"\"Given a docket string, format the string into a slug\n        that has the same signature as a database primary key.\n\n        Examples:\n            &gt;&gt;&gt; text = \"GR 138570, Oct. 10, 2000\"\n            &gt;&gt;&gt; Citation.get_docket_slug_from_text(text)\n            'gr-138570-2000-10-10'\n\n        Args:\n            v (str): The text to evaluate\n\n        Returns:\n            str | None: The slug to use, if possible.\n        \"\"\"\n        if cite := cls.extract_citation(v):\n            if cite.is_docket:\n                return cite.set_slug()\n        return None\n\n    def make_docket_row(self):\n        \"\"\"This presumes that a valid docket exists. Although a citation can\n        be a non-docket, e.g. phil, scra, etc., for purposes of creating a\n        a route-based row for a prospective decision object, the identifier will be\n        based on a docket id.\"\"\"\n        if id := self.set_slug():\n            return self.model_dump() | {\"id\": id}\n        logging.error(f\"Undocketable: {self=}\")\n        return None\n\n    @classmethod\n    def from_docket_row(\n        cls,\n        cat: str,\n        num: str,\n        date: str,\n        opt_phil: str | None,\n        opt_scra: str | None,\n        opt_offg: str | None,\n    ):\n        return cls(\n            cat=DocketCategory[cat.upper()],\n            num=num,\n            date=parse(date).date(),\n            phil=cls.get_report(opt_phil),\n            scra=cls.get_report(opt_scra),\n            offg=cls.get_report(opt_offg),\n        )\n\n    @cached_property\n    def is_docket(self) -&gt; bool:\n        return all([self.docket_category, self.docket_serial, self.docket_date])\n\n    @cached_property\n    def display_date(self):\n        \"\"\"This is the same as Docket@formatted_date.\"\"\"\n        if self.docket_date:\n            return self.docket_date.strftime(DOCKET_DATE_FORMAT)\n        return None\n\n    def get_docket_display(self) -&gt; str | None:\n        if self.is_docket:\n            return (\n                f\"{self.docket_category} No. {self.docket_serial}, {self.display_date}\"  # type: ignore # noqa: E501\n            )\n        return None\n\n    @classmethod\n    def get_report(cls, raw: str | None = None) -&gt; str | None:\n        \"\"\"Get a lower cased volpubpage of `publisher` from the `data`. Assumes\n        that the publisher key is either `phil`, `scra` or `offg`.\n\n        Examples:\n            &gt;&gt;&gt; raw = \"123 Phil. 123\"\n            &gt;&gt;&gt; Citation.get_report(raw)\n            '123 phil. 123'\n\n        Args:\n            publisher (str): _description_\n            data (dict): _description_\n\n        Returns:\n            str | None: _description_\n        \"\"\"\n        if not raw:\n            return None\n\n        try:\n            reports = Report.extract_reports(raw)\n            report = next(reports)\n            if result := report.volpubpage:\n                return result.lower()\n            else:\n                logging.warning(f\"No volpubpage {raw=}\")\n                return None\n        except StopIteration:\n            logging.warning(f\"No {raw=} report\")\n            return None\n\n    @classmethod\n    def _set_report(cls, text: str):\n        try:\n            obj = next(Report.extract_reports(text))\n            return cls(phil=obj.phil, scra=obj.scra, offg=obj.offg)\n        except StopIteration:\n            logging.debug(f\"{text} is not a Report instance.\")\n            return None\n\n    @classmethod\n    def _set_docket_report(cls, text: str):\n        try:\n            obj = next(CitableDocument.get_docketed_reports(text))\n            return cls(\n                cat=obj.category,\n                num=obj.serial_text,\n                date=obj.docket_date,\n                phil=obj.phil,\n                scra=obj.scra,\n                offg=obj.offg,\n            )\n        except StopIteration:\n            logging.debug(f\"{text} is not a Docket nor a Report instance.\")\n            return None\n\n    @classmethod\n    def extract_citations(cls, text: str) -&gt; Iterator[Self]:\n        \"\"\"Find citations and parse resulting strings to determine whether they are:\n\n        1. `Docket` + `Report` objects (in which case, `_set_docket_report()` will be used); or\n        2. `Report` objects (in which case `_set_report()` will be used)\n\n        Then processing each object so that they can be structured in a uniform format.\n\n        Examples:\n            &gt;&gt;&gt; text = \"&lt;em&gt;Gatchalian Promotions Talent Pool, Inc. v. Atty. Naldoza&lt;/em&gt;, 374 Phil. 1, 10-11 (1999), citing: &lt;em&gt;In re Almacen&lt;/em&gt;, 31 SCRA 562, 600 (1970).; People v. Umayam, G.R. No. 147033, April 30, 2003; &lt;i&gt;Bagong Alyansang Makabayan v. Zamora,&lt;/i&gt; G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449; Villegas &lt;em&gt;v.&lt;/em&gt; Subido, G.R. No. 31711, Sept. 30, 1971, 41 SCRA 190;\"\n            &gt;&gt;&gt; len(list(Citation.extract_citations(text)))\n            5\n\n        Args:\n            text (str): Text to evaluate\n\n        Yields:\n            Iterator[Self]: Itemized citations pre-processed via `CitableDocument`\n        \"\"\"  # noqa: E501\n        for cite in CitableDocument(text=text).get_citations():\n            if _docket := cls._set_docket_report(cite):\n                yield _docket\n            elif _report := cls._set_report(cite):\n                yield _report\n            else:\n                logging.error(f\"Skip invalid {cite=}.\")\n\n    @classmethod\n    def extract_citation(cls, text: str) -&gt; Self | None:\n        \"\"\"Thin wrapper over `cls.extract_citations()`.\n\n        Examples:\n            &gt;&gt;&gt; Citation.extract_citation('Hello World') is None\n            True\n            &gt;&gt;&gt; next(Citation.extract_citations('12 Phil. 24'))\n            &lt;Citation: 12 Phil. 24&gt;\n\n        Args:\n            text (str): Text to evaluate\n\n        Returns:\n            Self | None: First item found from `extract_citations`, if it exists.\n        \"\"\"\n        try:\n            return next(cls.extract_citations(text))\n        except StopIteration:\n            return None\n\n    @classmethod\n    def make_citation_string(\n        cls,\n        cat: str,\n        num: str,\n        date: str,\n        phil: str | None = None,\n        scra: str | None = None,\n        offg: str | None = None,\n    ) -&gt; str | None:\n        \"\"\"Assume that because of citation-utils, the extracted values are inputted into a database.\n\n        When the values are pulled from the database, it becomes necessary to convert these database (lowercased) values\n        to a unified properly-cased citation string with readable date (vs. isoformat db-counterpart).\n\n        Examples:\n            &gt;&gt;&gt; Citation.make_citation_string(cat='gr', num='111', date='2000-01-01', phil='100 phil. 100', scra='122 scra 100-a')\n            'G.R. No. 111, Jan. 1, 2000, 100 Phil. 100, 122 SCRA 100-A'\n\n        Args:\n            cat (str): The shorthand code for docket category\n            num (str): The serial identifier of the docket category\n            date (str): The date of `cat` + `num`\n            phil (str | None, optional): Phil. Reports. Defaults to None.\n            scra (str | None, optional): Supreme Court Reports Annotated. Defaults to None.\n            offg (str | None, optional): Official Gazette. Defaults to None.\n\n        Returns:\n            str | None: The combination of citation bits.\n        \"\"\"  # noqa: E501\n        bits = [\n            phil.title().split() if phil else None,\n            scra.upper().split() if scra else None,\n            offg.upper().split() if offg else None,\n        ]\n        cased_bits = [\n            f\"{bit[0].upper()} {bit[1]} {bit[2].upper()}\" for bit in bits if bit\n        ]\n        reports = \", \".join(cased_bits) if any(bits) else None\n        dt = datetime.date.fromisoformat(date).strftime(\"%b. %-d, %Y\")\n        match cat:\n            case \"gr\":\n                prefix = \"G.R.\"\n            case \"am\":\n                prefix = \"A.M.\"\n            case \"ac\":\n                prefix = \"A.C.\"\n            case \"bm\":\n                prefix = \"B.M.\"\n            case \"udk\":\n                prefix = \"UDK\"\n            case \"jib\":\n                prefix = \"JIB-FPI\"\n            case \"oca\":\n                prefix = \"OCA IPI\"\n            case \"pet\":\n                prefix = \"P.E.T.\"\n            case _:\n                return None\n        docket = f\"{prefix} No. {num.upper()}\"\n        bits = [bit for bit in [docket, dt, reports] if bit]\n        return \", \".join(bits)\n</code></pre>"},{"location":"#citation_utils.Citation-attributes","title":"Attributes","text":""},{"location":"#citation_utils.Citation.display_date","title":"<code>display_date</code>  <code>cached</code> <code>property</code>","text":"<p>This is the same as Docket@formatted_date.</p>"},{"location":"#citation_utils.Citation-functions","title":"Functions","text":""},{"location":"#citation_utils.Citation.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Helps <code>seen</code> variable in <code>CountedCitation</code>: either the docket bits match or any of the report fields match.</p> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>def __eq__(self, other: Self) -&gt; bool:\n    \"\"\"Helps `seen` variable in `CountedCitation`: either the docket bits match\n    or any of the report fields match.\"\"\"\n\n    def is_docket_match(other: Self) -&gt; bool:\n        \"\"\"All the docket elements must match to be equal.\"\"\"\n        cat_is_eq = (\n            self.docket_category is not None\n            and other.docket_category is not None\n            and (self.docket_category == other.docket_category)\n        )\n        num_is_eq = (\n            self.docket_serial is not None\n            and other.docket_serial is not None\n            and (self.docket_serial == other.docket_serial)\n        )\n        date_is_eq = (\n            self.docket_date is not None\n            and other.docket_date is not None\n            and (self.docket_date == other.docket_date)\n        )\n        return all([cat_is_eq, num_is_eq, date_is_eq])\n\n    if is_docket_match(other):\n        return True\n\n    return any(\n        [\n            self.scra and other.scra and self.scra.lower() == other.scra.lower(),\n            self.phil and other.phil and self.phil.lower() == other.phil.lower(),\n            self.offg and other.offg and self.offg.lower() == other.offg.lower(),\n        ]\n    )\n</code></pre>"},{"location":"#citation_utils.Citation.extract_citation","title":"<code>extract_citation(text)</code>  <code>classmethod</code>","text":"<p>Thin wrapper over <code>cls.extract_citations()</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; Citation.extract_citation('Hello World') is None\nTrue\n&gt;&gt;&gt; next(Citation.extract_citations('12 Phil. 24'))\n&lt;Citation: 12 Phil. 24&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to evaluate</p> required <p>Returns:</p> Type Description <code>Self | None</code> <p>Self | None: First item found from <code>extract_citations</code>, if it exists.</p> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef extract_citation(cls, text: str) -&gt; Self | None:\n    \"\"\"Thin wrapper over `cls.extract_citations()`.\n\n    Examples:\n        &gt;&gt;&gt; Citation.extract_citation('Hello World') is None\n        True\n        &gt;&gt;&gt; next(Citation.extract_citations('12 Phil. 24'))\n        &lt;Citation: 12 Phil. 24&gt;\n\n    Args:\n        text (str): Text to evaluate\n\n    Returns:\n        Self | None: First item found from `extract_citations`, if it exists.\n    \"\"\"\n    try:\n        return next(cls.extract_citations(text))\n    except StopIteration:\n        return None\n</code></pre>"},{"location":"#citation_utils.Citation.extract_citations","title":"<code>extract_citations(text)</code>  <code>classmethod</code>","text":"<p>Find citations and parse resulting strings to determine whether they are:</p> <ol> <li><code>Docket</code> + <code>Report</code> objects (in which case, <code>_set_docket_report()</code> will be used); or</li> <li><code>Report</code> objects (in which case <code>_set_report()</code> will be used)</li> </ol> <p>Then processing each object so that they can be structured in a uniform format.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"&lt;em&gt;Gatchalian Promotions Talent Pool, Inc. v. Atty. Naldoza&lt;/em&gt;, 374 Phil. 1, 10-11 (1999), citing: &lt;em&gt;In re Almacen&lt;/em&gt;, 31 SCRA 562, 600 (1970).; People v. Umayam, G.R. No. 147033, April 30, 2003; &lt;i&gt;Bagong Alyansang Makabayan v. Zamora,&lt;/i&gt; G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449; Villegas &lt;em&gt;v.&lt;/em&gt; Subido, G.R. No. 31711, Sept. 30, 1971, 41 SCRA 190;\"\n&gt;&gt;&gt; len(list(Citation.extract_citations(text)))\n5\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to evaluate</p> required <p>Yields:</p> Type Description <code>Self</code> <p>Iterator[Self]: Itemized citations pre-processed via <code>CitableDocument</code></p> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef extract_citations(cls, text: str) -&gt; Iterator[Self]:\n    \"\"\"Find citations and parse resulting strings to determine whether they are:\n\n    1. `Docket` + `Report` objects (in which case, `_set_docket_report()` will be used); or\n    2. `Report` objects (in which case `_set_report()` will be used)\n\n    Then processing each object so that they can be structured in a uniform format.\n\n    Examples:\n        &gt;&gt;&gt; text = \"&lt;em&gt;Gatchalian Promotions Talent Pool, Inc. v. Atty. Naldoza&lt;/em&gt;, 374 Phil. 1, 10-11 (1999), citing: &lt;em&gt;In re Almacen&lt;/em&gt;, 31 SCRA 562, 600 (1970).; People v. Umayam, G.R. No. 147033, April 30, 2003; &lt;i&gt;Bagong Alyansang Makabayan v. Zamora,&lt;/i&gt; G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449; Villegas &lt;em&gt;v.&lt;/em&gt; Subido, G.R. No. 31711, Sept. 30, 1971, 41 SCRA 190;\"\n        &gt;&gt;&gt; len(list(Citation.extract_citations(text)))\n        5\n\n    Args:\n        text (str): Text to evaluate\n\n    Yields:\n        Iterator[Self]: Itemized citations pre-processed via `CitableDocument`\n    \"\"\"  # noqa: E501\n    for cite in CitableDocument(text=text).get_citations():\n        if _docket := cls._set_docket_report(cite):\n            yield _docket\n        elif _report := cls._set_report(cite):\n            yield _report\n        else:\n            logging.error(f\"Skip invalid {cite=}.\")\n</code></pre>"},{"location":"#citation_utils.Citation.get_docket_slug_from_text","title":"<code>get_docket_slug_from_text(v)</code>  <code>classmethod</code>","text":"<p>Given a docket string, format the string into a slug that has the same signature as a database primary key.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"GR 138570, Oct. 10, 2000\"\n&gt;&gt;&gt; Citation.get_docket_slug_from_text(text)\n'gr-138570-2000-10-10'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The text to evaluate</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The slug to use, if possible.</p> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef get_docket_slug_from_text(cls, v: str) -&gt; str | None:\n    \"\"\"Given a docket string, format the string into a slug\n    that has the same signature as a database primary key.\n\n    Examples:\n        &gt;&gt;&gt; text = \"GR 138570, Oct. 10, 2000\"\n        &gt;&gt;&gt; Citation.get_docket_slug_from_text(text)\n        'gr-138570-2000-10-10'\n\n    Args:\n        v (str): The text to evaluate\n\n    Returns:\n        str | None: The slug to use, if possible.\n    \"\"\"\n    if cite := cls.extract_citation(v):\n        if cite.is_docket:\n            return cite.set_slug()\n    return None\n</code></pre>"},{"location":"#citation_utils.Citation.get_report","title":"<code>get_report(raw=None)</code>  <code>classmethod</code>","text":"<p>Get a lower cased volpubpage of <code>publisher</code> from the <code>data</code>. Assumes that the publisher key is either <code>phil</code>, <code>scra</code> or <code>offg</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; raw = \"123 Phil. 123\"\n&gt;&gt;&gt; Citation.get_report(raw)\n'123 phil. 123'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>publisher</code> <code>str</code> <p>description</p> required <code>data</code> <code>dict</code> <p>description</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: description</p> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef get_report(cls, raw: str | None = None) -&gt; str | None:\n    \"\"\"Get a lower cased volpubpage of `publisher` from the `data`. Assumes\n    that the publisher key is either `phil`, `scra` or `offg`.\n\n    Examples:\n        &gt;&gt;&gt; raw = \"123 Phil. 123\"\n        &gt;&gt;&gt; Citation.get_report(raw)\n        '123 phil. 123'\n\n    Args:\n        publisher (str): _description_\n        data (dict): _description_\n\n    Returns:\n        str | None: _description_\n    \"\"\"\n    if not raw:\n        return None\n\n    try:\n        reports = Report.extract_reports(raw)\n        report = next(reports)\n        if result := report.volpubpage:\n            return result.lower()\n        else:\n            logging.warning(f\"No volpubpage {raw=}\")\n            return None\n    except StopIteration:\n        logging.warning(f\"No {raw=} report\")\n        return None\n</code></pre>"},{"location":"#citation_utils.Citation.make_citation_string","title":"<code>make_citation_string(cat, num, date, phil=None, scra=None, offg=None)</code>  <code>classmethod</code>","text":"<p>Assume that because of citation-utils, the extracted values are inputted into a database.</p> <p>When the values are pulled from the database, it becomes necessary to convert these database (lowercased) values to a unified properly-cased citation string with readable date (vs. isoformat db-counterpart).</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; Citation.make_citation_string(cat='gr', num='111', date='2000-01-01', phil='100 phil. 100', scra='122 scra 100-a')\n'G.R. No. 111, Jan. 1, 2000, 100 Phil. 100, 122 SCRA 100-A'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cat</code> <code>str</code> <p>The shorthand code for docket category</p> required <code>num</code> <code>str</code> <p>The serial identifier of the docket category</p> required <code>date</code> <code>str</code> <p>The date of <code>cat</code> + <code>num</code></p> required <code>phil</code> <code>str | None</code> <p>Phil. Reports. Defaults to None.</p> <code>None</code> <code>scra</code> <code>str | None</code> <p>Supreme Court Reports Annotated. Defaults to None.</p> <code>None</code> <code>offg</code> <code>str | None</code> <p>Official Gazette. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The combination of citation bits.</p> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef make_citation_string(\n    cls,\n    cat: str,\n    num: str,\n    date: str,\n    phil: str | None = None,\n    scra: str | None = None,\n    offg: str | None = None,\n) -&gt; str | None:\n    \"\"\"Assume that because of citation-utils, the extracted values are inputted into a database.\n\n    When the values are pulled from the database, it becomes necessary to convert these database (lowercased) values\n    to a unified properly-cased citation string with readable date (vs. isoformat db-counterpart).\n\n    Examples:\n        &gt;&gt;&gt; Citation.make_citation_string(cat='gr', num='111', date='2000-01-01', phil='100 phil. 100', scra='122 scra 100-a')\n        'G.R. No. 111, Jan. 1, 2000, 100 Phil. 100, 122 SCRA 100-A'\n\n    Args:\n        cat (str): The shorthand code for docket category\n        num (str): The serial identifier of the docket category\n        date (str): The date of `cat` + `num`\n        phil (str | None, optional): Phil. Reports. Defaults to None.\n        scra (str | None, optional): Supreme Court Reports Annotated. Defaults to None.\n        offg (str | None, optional): Official Gazette. Defaults to None.\n\n    Returns:\n        str | None: The combination of citation bits.\n    \"\"\"  # noqa: E501\n    bits = [\n        phil.title().split() if phil else None,\n        scra.upper().split() if scra else None,\n        offg.upper().split() if offg else None,\n    ]\n    cased_bits = [\n        f\"{bit[0].upper()} {bit[1]} {bit[2].upper()}\" for bit in bits if bit\n    ]\n    reports = \", \".join(cased_bits) if any(bits) else None\n    dt = datetime.date.fromisoformat(date).strftime(\"%b. %-d, %Y\")\n    match cat:\n        case \"gr\":\n            prefix = \"G.R.\"\n        case \"am\":\n            prefix = \"A.M.\"\n        case \"ac\":\n            prefix = \"A.C.\"\n        case \"bm\":\n            prefix = \"B.M.\"\n        case \"udk\":\n            prefix = \"UDK\"\n        case \"jib\":\n            prefix = \"JIB-FPI\"\n        case \"oca\":\n            prefix = \"OCA IPI\"\n        case \"pet\":\n            prefix = \"P.E.T.\"\n        case _:\n            return None\n    docket = f\"{prefix} No. {num.upper()}\"\n    bits = [bit for bit in [docket, dt, reports] if bit]\n    return \", \".join(bits)\n</code></pre>"},{"location":"#citation_utils.Citation.make_docket_row","title":"<code>make_docket_row()</code>","text":"<p>This presumes that a valid docket exists. Although a citation can be a non-docket, e.g. phil, scra, etc., for purposes of creating a a route-based row for a prospective decision object, the identifier will be based on a docket id.</p> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>def make_docket_row(self):\n    \"\"\"This presumes that a valid docket exists. Although a citation can\n    be a non-docket, e.g. phil, scra, etc., for purposes of creating a\n    a route-based row for a prospective decision object, the identifier will be\n    based on a docket id.\"\"\"\n    if id := self.set_slug():\n        return self.model_dump() | {\"id\": id}\n    logging.error(f\"Undocketable: {self=}\")\n    return None\n</code></pre>"},{"location":"#citation_utils.Citation.ser_model","title":"<code>ser_model()</code>","text":"<p>Generate a database row-friendly format of the model. Note the different field names: <code>cat</code>, <code>num</code>, <code>dt</code>, <code>phil</code>, <code>scra</code>, <code>offg</code> map to either a usable database value or <code>None</code>. The docket values here have the option to be <code>None</code> since some citations, especially the legacy variants, do not include their docket equivalents in the source texts.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"OCA IPI No. 10-3450-P, Feb. 06, 2008\"\n&gt;&gt;&gt; cite = Citation.extract_citation(text)\n&gt;&gt;&gt; cite.model_dump_json()\n'{\"cat\":\"oca\",\"num\":\"10-3450-p\",\"date\":\"2008-02-06\",\"phil\":null,\"scra\":null,\"offg\":null}'\n</code></pre> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>@model_serializer\ndef ser_model(self) -&gt; dict[str, str | datetime.date | None]:\n    \"\"\"Generate a database row-friendly format of the model. Note the different\n    field names: `cat`, `num`, `dt`, `phil`, `scra`, `offg` map to either a usable\n    database value or `None`. The docket values here have the option to be `None`\n    since some citations, especially the legacy variants, do not include their\n    docket equivalents in the source texts.\n\n    Examples:\n        &gt;&gt;&gt; text = \"OCA IPI No. 10-3450-P, Feb. 06, 2008\"\n        &gt;&gt;&gt; cite = Citation.extract_citation(text)\n        &gt;&gt;&gt; cite.model_dump_json()\n        '{\"cat\":\"oca\",\"num\":\"10-3450-p\",\"date\":\"2008-02-06\",\"phil\":null,\"scra\":null,\"offg\":null}'\n\n    \"\"\"\n    return {\n        \"cat\": self.serialize_cat(self.docket_category),\n        \"num\": self.serialize_num(self.docket_serial),\n        \"date\": self.serialize_dt(self.docket_date),\n        \"phil\": self.serialize_phil(self.phil),\n        \"scra\": self.serialize_scra(self.scra),\n        \"offg\": self.serialize_offg(self.offg),\n    }\n</code></pre>"},{"location":"#citation_utils.Citation.set_slug","title":"<code>set_slug()</code>","text":"<p>Create a unique identifier of a decision.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"GR 138570, Oct. 10, 2000\"\n&gt;&gt;&gt; Citation.extract_citation(text).set_slug()\n'gr-138570-2000-10-10'\n</code></pre> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>def set_slug(self) -&gt; str | None:\n    \"\"\"Create a unique identifier of a decision.\n\n    Examples:\n        &gt;&gt;&gt; text = \"GR 138570, Oct. 10, 2000\"\n        &gt;&gt;&gt; Citation.extract_citation(text).set_slug()\n        'gr-138570-2000-10-10'\n\n    \"\"\"\n    bits = [\n        self.serialize_cat(self.docket_category),\n        self.serialize_num(self.docket_serial),\n        self.serialize_dt(self.docket_date),\n    ]\n    if all(bits):\n        return \"-\".join(bits)  # type: ignore\n    return None\n</code></pre>"},{"location":"#countedcitation","title":"CountedCitation","text":"<p>               Bases: <code>Citation</code></p> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>class CountedCitation(Citation):\n    mentions: int = Field(default=1, description=\"Get count via Citation __eq__\")\n\n    def __repr__(self) -&gt; str:\n        return f\"{str(self)}: {self.mentions}\"\n\n    @model_serializer\n    def ser_model(self) -&gt; dict[str, str | datetime.date | int | None]:\n        return {\n            \"cat\": self.serialize_cat(self.docket_category),\n            \"num\": self.serialize_num(self.docket_serial),\n            \"date\": self.serialize_dt(self.docket_date),\n            \"phil\": self.serialize_phil(self.phil),\n            \"scra\": self.serialize_scra(self.scra),\n            \"offg\": self.serialize_offg(self.offg),\n            \"mentions\": self.mentions,\n        }\n\n    @classmethod\n    def from_source(cls, text: str) -&gt; list[Self]:\n        \"\"\"Computes mentions of `counted_dockets()` vis-a-vis `counted_reports()` and\n        count the number of unique items, taking into account the Citation\n        structure and the use of __eq__ re: what is considered unique.\n\n        Examples:\n            &gt;&gt;&gt; source = \"374 Phil. 1, 10-11 (1999) 1111 SCRA 1111; G.R. No. 147033, April 30, 2003; G.R. No. 147033, April 30, 2003, 374 Phil. 1, 600; ABC v. XYZ, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449;  XXX, G.R. No. 31711, Sept. 30, 1971, 35 SCRA 190; Hello World, 1111 SCRA 1111; Y v. Z, 35 SCRA 190; 1 Off. Gaz. 41 Bar Matter No. 803, Jan. 1, 2000 Bar Matter No. 411, Feb. 1, 2000 Bar Matter No. 412, Jan. 1, 2000, 1111 SCRA 1111; 374 Phil. 1\"\n            &gt;&gt;&gt; len(CountedCitation.from_source(source))\n            5\n\n        Args:\n            text (str): Text to Evaluate.\n\n        Returns:\n            list[Self]: Unique citations with their counts.\n        \"\"\"  # noqa: E501\n        all_reports = cls.counted_reports(text)  # includes reports in docket_reports\n        if drs := cls.counted_docket_reports(text):\n            for dr in drs:\n                for report in all_reports:\n                    if report == dr:  # uses Citation __eq__\n                        balance = 0\n                        if report.mentions &gt; dr.mentions:\n                            balance = report.mentions - dr.mentions\n                        dr.mentions = dr.mentions + balance\n                        report.mentions = 0\n            return drs + [report for report in all_reports if report.mentions &gt; 0]\n        return all_reports\n\n    @classmethod\n    def from_repr_format(cls, repr_texts: list[str]) -&gt; Iterator[Self]:\n        \"\"\"Generate their pydantic counterparts from `&lt;cat&gt; &lt;id&gt;: &lt;mentions&gt;` format.\n\n        Examples:\n            &gt;&gt;&gt; repr_texts = ['BM No. 412, Jan 01, 2000, 1111 SCRA 1111: 3', 'GR No. 147033, Apr 30, 2003, 374 Phil. 1: 1']\n            &gt;&gt;&gt; results = list(CountedCitation.from_repr_format(repr_texts))\n            &gt;&gt;&gt; len(results)\n            2\n            &gt;&gt;&gt; results[0].model_dump()\n            {'cat': 'bm', 'num': '412', 'date': '2000-01-01', 'phil': None, 'scra': '1111 scra 1111', 'offg': None, 'mentions': 3}\n            &gt;&gt;&gt; results[1].model_dump()\n            {'cat': 'gr', 'num': '147033', 'date': '2003-04-30', 'phil': '374 phil. 1', 'scra': None, 'offg': None, 'mentions': 1}\n\n        Args:\n            repr_texts (str): list of texts having `__repr__` format of a `CountedRule`\n\n        Yields:\n            Iterator[Self]: Instances of CountedCitation.\n        \"\"\"  # noqa: E501\n        for text in repr_texts:\n            counted_bits = text.split(\":\")\n            if len(counted_bits) == 2:\n                if cite := cls.extract_citation(counted_bits[0].strip()):\n                    citation = cls(\n                        cat=cite.docket_category,\n                        num=cite.docket_serial,\n                        date=cite.docket_date,\n                        phil=cite.phil,\n                        scra=cite.scra,\n                        offg=cite.offg,\n                    )\n                    citation.mentions = int(counted_bits[1].strip())\n                    yield citation\n\n    @classmethod\n    def counted_reports(cls, text: str):\n        \"\"\"Detect _reports_ only from source `text` by first converting\n        raw citations into a `Citation` object to take advantage of `__eq__` in\n        a `seen` list. This will also populate the the unique records with missing\n        values.\n        \"\"\"\n        seen: list[cls] = []\n        reports = Report.extract_reports(text=text)\n        for report in reports:\n            cite = Citation(phil=report.phil, scra=report.scra, offg=report.offg)\n            if cite not in seen:\n                seen.append(cls(**cite.model_dump()))\n            else:\n                included = seen[seen.index(cite)]\n                included.mentions += 1\n        return seen\n\n    @classmethod\n    def counted_docket_reports(cls, text: str):\n        \"\"\"Detect _dockets with reports_ from source `text` by first converting\n        raw citations into a `Citation` object to take advantage of `__eq__` in\n        a `seen` list. Will populate unique records with missing values.\n        \"\"\"\n\n        seen: list[cls] = []\n        for obj in CitableDocument.get_docketed_reports(text=text):\n            cite = Citation(\n                cat=obj.category,\n                num=obj.serial_text,\n                date=obj.docket_date,\n                phil=obj.phil,\n                scra=obj.scra,\n                offg=obj.offg,\n            )\n            if cite not in seen:\n                seen_citation = cls(\n                    cat=cite.docket_category,\n                    num=cite.docket_serial,\n                    date=cite.docket_date,\n                    phil=cite.phil,\n                    scra=cite.scra,\n                    offg=cite.offg,\n                )\n                seen.append(seen_citation)\n            else:\n                included = seen[seen.index(cite)]\n                included.mentions += 1\n                included.add_values(cite)  # for citations, can add missing\n        return seen\n\n    def add_values(self, other: Citation):\n        if not self.docket_category and other.docket_category:\n            self.docket_category = other.docket_category\n\n        if not self.docket_serial and other.docket_serial:\n            self.docket_serial = other.docket_serial\n\n        if not self.docket_date and other.docket_date:\n            self.docket_date = other.docket_date\n\n        if not self.scra and other.scra:\n            self.scra = other.scra\n\n        if not self.phil and other.phil:\n            self.phil = other.phil\n\n        if not self.offg and other.offg:\n            self.offg = other.offg\n</code></pre>"},{"location":"#citation_utils.CountedCitation-functions","title":"Functions","text":""},{"location":"#citation_utils.CountedCitation.counted_docket_reports","title":"<code>counted_docket_reports(text)</code>  <code>classmethod</code>","text":"<p>Detect dockets with reports from source <code>text</code> by first converting raw citations into a <code>Citation</code> object to take advantage of <code>__eq__</code> in a <code>seen</code> list. Will populate unique records with missing values.</p> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef counted_docket_reports(cls, text: str):\n    \"\"\"Detect _dockets with reports_ from source `text` by first converting\n    raw citations into a `Citation` object to take advantage of `__eq__` in\n    a `seen` list. Will populate unique records with missing values.\n    \"\"\"\n\n    seen: list[cls] = []\n    for obj in CitableDocument.get_docketed_reports(text=text):\n        cite = Citation(\n            cat=obj.category,\n            num=obj.serial_text,\n            date=obj.docket_date,\n            phil=obj.phil,\n            scra=obj.scra,\n            offg=obj.offg,\n        )\n        if cite not in seen:\n            seen_citation = cls(\n                cat=cite.docket_category,\n                num=cite.docket_serial,\n                date=cite.docket_date,\n                phil=cite.phil,\n                scra=cite.scra,\n                offg=cite.offg,\n            )\n            seen.append(seen_citation)\n        else:\n            included = seen[seen.index(cite)]\n            included.mentions += 1\n            included.add_values(cite)  # for citations, can add missing\n    return seen\n</code></pre>"},{"location":"#citation_utils.CountedCitation.counted_reports","title":"<code>counted_reports(text)</code>  <code>classmethod</code>","text":"<p>Detect reports only from source <code>text</code> by first converting raw citations into a <code>Citation</code> object to take advantage of <code>__eq__</code> in a <code>seen</code> list. This will also populate the the unique records with missing values.</p> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef counted_reports(cls, text: str):\n    \"\"\"Detect _reports_ only from source `text` by first converting\n    raw citations into a `Citation` object to take advantage of `__eq__` in\n    a `seen` list. This will also populate the the unique records with missing\n    values.\n    \"\"\"\n    seen: list[cls] = []\n    reports = Report.extract_reports(text=text)\n    for report in reports:\n        cite = Citation(phil=report.phil, scra=report.scra, offg=report.offg)\n        if cite not in seen:\n            seen.append(cls(**cite.model_dump()))\n        else:\n            included = seen[seen.index(cite)]\n            included.mentions += 1\n    return seen\n</code></pre>"},{"location":"#citation_utils.CountedCitation.from_repr_format","title":"<code>from_repr_format(repr_texts)</code>  <code>classmethod</code>","text":"<p>Generate their pydantic counterparts from <code>&lt;cat&gt; &lt;id&gt;: &lt;mentions&gt;</code> format.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; repr_texts = ['BM No. 412, Jan 01, 2000, 1111 SCRA 1111: 3', 'GR No. 147033, Apr 30, 2003, 374 Phil. 1: 1']\n&gt;&gt;&gt; results = list(CountedCitation.from_repr_format(repr_texts))\n&gt;&gt;&gt; len(results)\n2\n&gt;&gt;&gt; results[0].model_dump()\n{'cat': 'bm', 'num': '412', 'date': '2000-01-01', 'phil': None, 'scra': '1111 scra 1111', 'offg': None, 'mentions': 3}\n&gt;&gt;&gt; results[1].model_dump()\n{'cat': 'gr', 'num': '147033', 'date': '2003-04-30', 'phil': '374 phil. 1', 'scra': None, 'offg': None, 'mentions': 1}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>repr_texts</code> <code>str</code> <p>list of texts having <code>__repr__</code> format of a <code>CountedRule</code></p> required <p>Yields:</p> Type Description <code>Self</code> <p>Iterator[Self]: Instances of CountedCitation.</p> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef from_repr_format(cls, repr_texts: list[str]) -&gt; Iterator[Self]:\n    \"\"\"Generate their pydantic counterparts from `&lt;cat&gt; &lt;id&gt;: &lt;mentions&gt;` format.\n\n    Examples:\n        &gt;&gt;&gt; repr_texts = ['BM No. 412, Jan 01, 2000, 1111 SCRA 1111: 3', 'GR No. 147033, Apr 30, 2003, 374 Phil. 1: 1']\n        &gt;&gt;&gt; results = list(CountedCitation.from_repr_format(repr_texts))\n        &gt;&gt;&gt; len(results)\n        2\n        &gt;&gt;&gt; results[0].model_dump()\n        {'cat': 'bm', 'num': '412', 'date': '2000-01-01', 'phil': None, 'scra': '1111 scra 1111', 'offg': None, 'mentions': 3}\n        &gt;&gt;&gt; results[1].model_dump()\n        {'cat': 'gr', 'num': '147033', 'date': '2003-04-30', 'phil': '374 phil. 1', 'scra': None, 'offg': None, 'mentions': 1}\n\n    Args:\n        repr_texts (str): list of texts having `__repr__` format of a `CountedRule`\n\n    Yields:\n        Iterator[Self]: Instances of CountedCitation.\n    \"\"\"  # noqa: E501\n    for text in repr_texts:\n        counted_bits = text.split(\":\")\n        if len(counted_bits) == 2:\n            if cite := cls.extract_citation(counted_bits[0].strip()):\n                citation = cls(\n                    cat=cite.docket_category,\n                    num=cite.docket_serial,\n                    date=cite.docket_date,\n                    phil=cite.phil,\n                    scra=cite.scra,\n                    offg=cite.offg,\n                )\n                citation.mentions = int(counted_bits[1].strip())\n                yield citation\n</code></pre>"},{"location":"#citation_utils.CountedCitation.from_source","title":"<code>from_source(text)</code>  <code>classmethod</code>","text":"<p>Computes mentions of <code>counted_dockets()</code> vis-a-vis <code>counted_reports()</code> and count the number of unique items, taking into account the Citation structure and the use of eq re: what is considered unique.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; source = \"374 Phil. 1, 10-11 (1999) 1111 SCRA 1111; G.R. No. 147033, April 30, 2003; G.R. No. 147033, April 30, 2003, 374 Phil. 1, 600; ABC v. XYZ, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449;  XXX, G.R. No. 31711, Sept. 30, 1971, 35 SCRA 190; Hello World, 1111 SCRA 1111; Y v. Z, 35 SCRA 190; 1 Off. Gaz. 41 Bar Matter No. 803, Jan. 1, 2000 Bar Matter No. 411, Feb. 1, 2000 Bar Matter No. 412, Jan. 1, 2000, 1111 SCRA 1111; 374 Phil. 1\"\n&gt;&gt;&gt; len(CountedCitation.from_source(source))\n5\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to Evaluate.</p> required <p>Returns:</p> Type Description <code>list[Self]</code> <p>list[Self]: Unique citations with their counts.</p> Source code in <code>src/citation_utils/citation.py</code> Python<pre><code>@classmethod\ndef from_source(cls, text: str) -&gt; list[Self]:\n    \"\"\"Computes mentions of `counted_dockets()` vis-a-vis `counted_reports()` and\n    count the number of unique items, taking into account the Citation\n    structure and the use of __eq__ re: what is considered unique.\n\n    Examples:\n        &gt;&gt;&gt; source = \"374 Phil. 1, 10-11 (1999) 1111 SCRA 1111; G.R. No. 147033, April 30, 2003; G.R. No. 147033, April 30, 2003, 374 Phil. 1, 600; ABC v. XYZ, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449;  XXX, G.R. No. 31711, Sept. 30, 1971, 35 SCRA 190; Hello World, 1111 SCRA 1111; Y v. Z, 35 SCRA 190; 1 Off. Gaz. 41 Bar Matter No. 803, Jan. 1, 2000 Bar Matter No. 411, Feb. 1, 2000 Bar Matter No. 412, Jan. 1, 2000, 1111 SCRA 1111; 374 Phil. 1\"\n        &gt;&gt;&gt; len(CountedCitation.from_source(source))\n        5\n\n    Args:\n        text (str): Text to Evaluate.\n\n    Returns:\n        list[Self]: Unique citations with their counts.\n    \"\"\"  # noqa: E501\n    all_reports = cls.counted_reports(text)  # includes reports in docket_reports\n    if drs := cls.counted_docket_reports(text):\n        for dr in drs:\n            for report in all_reports:\n                if report == dr:  # uses Citation __eq__\n                    balance = 0\n                    if report.mentions &gt; dr.mentions:\n                        balance = report.mentions - dr.mentions\n                    dr.mentions = dr.mentions + balance\n                    report.mentions = 0\n        return drs + [report for report in all_reports if report.mentions &gt; 0]\n    return all_reports\n</code></pre>"},{"location":"citeable/","title":"Specific Types","text":""},{"location":"citeable/#docket-report-citation","title":"Docket Report Citation","text":"<p>               Bases: <code>Docket</code>, <code>Report</code>, <code>ABC</code></p> <p>Note <code>Report</code> is defined in a separate library <code>citation-report</code>.</p> <p>The <code>DocketReportCitation</code> abstract class makes sure that all of the fields of a Docket object alongside all of the fields of a <code>Report</code> object will be utilized. It also mandates the implementation of a<code>cls.search()</code> method.</p> Source code in <code>src/citation_utils/dockets/models/docket_citation.py</code> Python<pre><code>class DocketReportCitation(Docket, Report, abc.ABC):\n    \"\"\"Note `Report` is defined in a separate library `citation-report`.\n\n    The `DocketReportCitation` abstract class makes sure that all of the\n    fields of a [Docket][docket-model] object alongside all of the fields of a `Report`\n    object will be utilized. It also mandates the implementation of a`cls.search()`\n    method.\n    \"\"\"\n\n    @property\n    def _docket(self):\n        if self.first_id:\n            return f\"{self.category.name} No. {self.serial_text}, {self.formatted_date}\"\n        elif self.ids:\n            return f\"{self.category.name} No. {self.ids}, {self.formatted_date}\"\n        return None\n\n    @property\n    def _report(self):\n        return self.volpubpage or None\n\n    def __str__(self) -&gt; str:\n        if self._docket and self._report:\n            return f\"{self._docket}, {self._report}\"\n        elif self._docket:\n            return self._docket\n        elif self._report:\n            return self._report\n        return \"No citation.\"\n\n    def __repr__(self) -&gt; str:\n        if self._docket and self._report:\n            return f\"&lt;DocketReport: {self._docket} | {self._report}&gt;\"\n        elif self._docket:\n            return f\"&lt;DocketReport: {self._docket}&gt;\"\n        elif self._report:\n            return f\"&lt;DocketReport: {self._report}&gt;\"\n        return \"&lt;DocketReport: improper citation&gt;\"\n\n    @classmethod\n    @abc.abstractmethod\n    def search(cls, raw: str) -&gt; Iterator[Self]:\n        raise NotImplementedError(\"Search method must produce Iterator of instance.\")\n</code></pre>"},{"location":"citeable/#general-register","title":"General Register","text":"<p>               Bases: <code>DocketReportCitation</code></p> Source code in <code>src/citation_utils/dockets/constructed_gr.py</code> Python<pre><code>class CitationGR(DocketReportCitation):\n    ...\n\n    @classmethod\n    def search(cls, text: str) -&gt; Iterator[Self]:\n        \"\"\"Get all dockets matching the `GR` docket pattern, inclusive of their optional Report object.\n\n        Examples:\n            &gt;&gt;&gt; text = \"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"\n            &gt;&gt;&gt; cite = next(CitationGR.search(text))\n            &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n            {'publisher': 'SCRA', 'volume': '342', 'page': '449', 'context': 'G.R. Nos. 138570, 138572, 138587, 138680, 138698', 'category': 'GR', 'ids': '138570, 138572, 138587, 138680, 138698', 'docket_date': datetime.date(2000, 10, 10)}\n\n        Args:\n            text (str): Text to look for citation objects\n\n        Yields:\n            Iterator[Self]: Combination of Docket and Report pydantic model.\n        \"\"\"  # noqa E501\n        for result in constructed_gr.detect(text):\n            yield cls(**result)\n</code></pre>"},{"location":"citeable/#citation_utils.dockets.constructed_gr.CitationGR-functions","title":"Functions","text":""},{"location":"citeable/#citation_utils.dockets.constructed_gr.CitationGR.search","title":"<code>search(text)</code>  <code>classmethod</code>","text":"<p>Get all dockets matching the <code>GR</code> docket pattern, inclusive of their optional Report object.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"\n&gt;&gt;&gt; cite = next(CitationGR.search(text))\n&gt;&gt;&gt; cite.model_dump(exclude_none=True)\n{'publisher': 'SCRA', 'volume': '342', 'page': '449', 'context': 'G.R. Nos. 138570, 138572, 138587, 138680, 138698', 'category': 'GR', 'ids': '138570, 138572, 138587, 138680, 138698', 'docket_date': datetime.date(2000, 10, 10)}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for citation objects</p> required <p>Yields:</p> Type Description <code>Self</code> <p>Iterator[Self]: Combination of Docket and Report pydantic model.</p> Source code in <code>src/citation_utils/dockets/constructed_gr.py</code> Python<pre><code>@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n    \"\"\"Get all dockets matching the `GR` docket pattern, inclusive of their optional Report object.\n\n    Examples:\n        &gt;&gt;&gt; text = \"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"\n        &gt;&gt;&gt; cite = next(CitationGR.search(text))\n        &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n        {'publisher': 'SCRA', 'volume': '342', 'page': '449', 'context': 'G.R. Nos. 138570, 138572, 138587, 138680, 138698', 'category': 'GR', 'ids': '138570, 138572, 138587, 138680, 138698', 'docket_date': datetime.date(2000, 10, 10)}\n\n    Args:\n        text (str): Text to look for citation objects\n\n    Yields:\n        Iterator[Self]: Combination of Docket and Report pydantic model.\n    \"\"\"  # noqa E501\n    for result in constructed_gr.detect(text):\n        yield cls(**result)\n</code></pre>"},{"location":"citeable/#administrative-matter","title":"Administrative Matter","text":"<p>               Bases: <code>DocketReportCitation</code></p> Source code in <code>src/citation_utils/dockets/constructed_am.py</code> Python<pre><code>class CitationAM(DocketReportCitation):\n    ...\n\n    @classmethod\n    def search(cls, text: str) -&gt; Iterator[Self]:\n        \"\"\"Get all dockets matching the `AM` docket pattern, inclusive of their optional Report object.\n\n        Examples:\n            &gt;&gt;&gt; text = \"A.M. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n            &gt;&gt;&gt; cite = next(CitationAM.search(text))\n            &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n            {'publisher': 'SCRA', 'volume': '206', 'page': '491', 'context': 'A.M. No. P-88-198', 'category': 'AM', 'ids': 'P-88-198', 'docket_date': datetime.date(1992, 2, 25)}\n\n        Args:\n            text (str): Text to look for citation objects\n\n        Yields:\n            Iterator[Self]: Combination of Docket and Report pydantic model.\n        \"\"\"  # noqa E501\n        for result in constructed_am.detect(text):\n            yield cls(**result)\n</code></pre>"},{"location":"citeable/#citation_utils.dockets.constructed_am.CitationAM-functions","title":"Functions","text":""},{"location":"citeable/#citation_utils.dockets.constructed_am.CitationAM.search","title":"<code>search(text)</code>  <code>classmethod</code>","text":"<p>Get all dockets matching the <code>AM</code> docket pattern, inclusive of their optional Report object.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"A.M. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n&gt;&gt;&gt; cite = next(CitationAM.search(text))\n&gt;&gt;&gt; cite.model_dump(exclude_none=True)\n{'publisher': 'SCRA', 'volume': '206', 'page': '491', 'context': 'A.M. No. P-88-198', 'category': 'AM', 'ids': 'P-88-198', 'docket_date': datetime.date(1992, 2, 25)}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for citation objects</p> required <p>Yields:</p> Type Description <code>Self</code> <p>Iterator[Self]: Combination of Docket and Report pydantic model.</p> Source code in <code>src/citation_utils/dockets/constructed_am.py</code> Python<pre><code>@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n    \"\"\"Get all dockets matching the `AM` docket pattern, inclusive of their optional Report object.\n\n    Examples:\n        &gt;&gt;&gt; text = \"A.M. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n        &gt;&gt;&gt; cite = next(CitationAM.search(text))\n        &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n        {'publisher': 'SCRA', 'volume': '206', 'page': '491', 'context': 'A.M. No. P-88-198', 'category': 'AM', 'ids': 'P-88-198', 'docket_date': datetime.date(1992, 2, 25)}\n\n    Args:\n        text (str): Text to look for citation objects\n\n    Yields:\n        Iterator[Self]: Combination of Docket and Report pydantic model.\n    \"\"\"  # noqa E501\n    for result in constructed_am.detect(text):\n        yield cls(**result)\n</code></pre>"},{"location":"citeable/#administrative-case","title":"Administrative Case","text":"<p>               Bases: <code>DocketReportCitation</code></p> Source code in <code>src/citation_utils/dockets/constructed_ac.py</code> Python<pre><code>class CitationAC(DocketReportCitation):\n    ...\n\n    @classmethod\n    def search(cls, text: str) -&gt; Iterator[Self]:\n        \"\"\"Get all dockets matching the `AC` docket pattern, inclusive of their optional Report object.\n\n        Examples:\n            &gt;&gt;&gt; text = \"A.C. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n            &gt;&gt;&gt; cite = next(CitationAC.search(text))\n            &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n            {'publisher': 'SCRA', 'volume': '206', 'page': '491', 'context': 'A.C. No. P-88-198', 'category': 'AC', 'ids': 'P-88-198', 'docket_date': datetime.date(1992, 2, 25)}\n\n        Args:\n            text (str): Text to look for citation objects\n\n        Yields:\n            Iterator[Self]: Combination of Docket and Report pydantic model.\n        \"\"\"  # noqa E501\n        for result in constructed_ac.detect(text):\n            yield cls(**result)\n</code></pre>"},{"location":"citeable/#citation_utils.dockets.constructed_ac.CitationAC-functions","title":"Functions","text":""},{"location":"citeable/#citation_utils.dockets.constructed_ac.CitationAC.search","title":"<code>search(text)</code>  <code>classmethod</code>","text":"<p>Get all dockets matching the <code>AC</code> docket pattern, inclusive of their optional Report object.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"A.C. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n&gt;&gt;&gt; cite = next(CitationAC.search(text))\n&gt;&gt;&gt; cite.model_dump(exclude_none=True)\n{'publisher': 'SCRA', 'volume': '206', 'page': '491', 'context': 'A.C. No. P-88-198', 'category': 'AC', 'ids': 'P-88-198', 'docket_date': datetime.date(1992, 2, 25)}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for citation objects</p> required <p>Yields:</p> Type Description <code>Self</code> <p>Iterator[Self]: Combination of Docket and Report pydantic model.</p> Source code in <code>src/citation_utils/dockets/constructed_ac.py</code> Python<pre><code>@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n    \"\"\"Get all dockets matching the `AC` docket pattern, inclusive of their optional Report object.\n\n    Examples:\n        &gt;&gt;&gt; text = \"A.C. No. P-88-198, February 25, 1992, 206 SCRA 491.\"\n        &gt;&gt;&gt; cite = next(CitationAC.search(text))\n        &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n        {'publisher': 'SCRA', 'volume': '206', 'page': '491', 'context': 'A.C. No. P-88-198', 'category': 'AC', 'ids': 'P-88-198', 'docket_date': datetime.date(1992, 2, 25)}\n\n    Args:\n        text (str): Text to look for citation objects\n\n    Yields:\n        Iterator[Self]: Combination of Docket and Report pydantic model.\n    \"\"\"  # noqa E501\n    for result in constructed_ac.detect(text):\n        yield cls(**result)\n</code></pre>"},{"location":"citeable/#bar-matter","title":"Bar Matter","text":"<p>               Bases: <code>DocketReportCitation</code></p> Source code in <code>src/citation_utils/dockets/constructed_bm.py</code> Python<pre><code>class CitationBM(DocketReportCitation):\n    ...\n\n    @classmethod\n    def search(cls, text: str) -&gt; Iterator[Self]:\n        \"\"\"Get all dockets matching the `BM` docket pattern, inclusive of their optional Report object.\n\n        Examples:\n            &gt;&gt;&gt; text = \"B.M. No. 1678, December 17, 2007\"\n            &gt;&gt;&gt; cite = next(CitationBM.search(text))\n            &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n            {'context': 'B.M. No. 1678', 'category': 'BM', 'ids': '1678', 'docket_date': datetime.date(2007, 12, 17)}\n\n        Args:\n            text (str): Text to look for citation objects\n\n        Yields:\n            Iterator[Self]: Combination of Docket and Report pydantic model.\n        \"\"\"  # noqa E501\n        for result in constructed_bm.detect(text):\n            yield cls(**result)\n</code></pre>"},{"location":"citeable/#citation_utils.dockets.constructed_bm.CitationBM-functions","title":"Functions","text":""},{"location":"citeable/#citation_utils.dockets.constructed_bm.CitationBM.search","title":"<code>search(text)</code>  <code>classmethod</code>","text":"<p>Get all dockets matching the <code>BM</code> docket pattern, inclusive of their optional Report object.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"B.M. No. 1678, December 17, 2007\"\n&gt;&gt;&gt; cite = next(CitationBM.search(text))\n&gt;&gt;&gt; cite.model_dump(exclude_none=True)\n{'context': 'B.M. No. 1678', 'category': 'BM', 'ids': '1678', 'docket_date': datetime.date(2007, 12, 17)}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for citation objects</p> required <p>Yields:</p> Type Description <code>Self</code> <p>Iterator[Self]: Combination of Docket and Report pydantic model.</p> Source code in <code>src/citation_utils/dockets/constructed_bm.py</code> Python<pre><code>@classmethod\ndef search(cls, text: str) -&gt; Iterator[Self]:\n    \"\"\"Get all dockets matching the `BM` docket pattern, inclusive of their optional Report object.\n\n    Examples:\n        &gt;&gt;&gt; text = \"B.M. No. 1678, December 17, 2007\"\n        &gt;&gt;&gt; cite = next(CitationBM.search(text))\n        &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n        {'context': 'B.M. No. 1678', 'category': 'BM', 'ids': '1678', 'docket_date': datetime.date(2007, 12, 17)}\n\n    Args:\n        text (str): Text to look for citation objects\n\n    Yields:\n        Iterator[Self]: Combination of Docket and Report pydantic model.\n    \"\"\"  # noqa E501\n    for result in constructed_bm.detect(text):\n        yield cls(**result)\n</code></pre>"},{"location":"sqlite/","title":"sqlite analysis","text":"<p>Assume you're able to collect citations and place them into a database with the fields previously established:</p>"},{"location":"sqlite/#multiple-category-and-serial-having-the-same-values","title":"Multiple category and serial having the same values","text":"<p>This state is valid but should result in connected decisions, e.g. a motion for reconsideration resolves an earlier decided case. This is the reason that a citation needs a <code>docket date</code> to distinguish connected cases.</p> <p>Consider for instance the following query:</p> SQL<pre><code>select\n docket_category, docket_serial, docket_date\nfrom\n valid\nwhere\n docket_category = \"GR\"\n and docket_serial = '109645'\norder by docket_date desc\n</code></pre> <p>Yielding the connected Ortigas decision rows which can be considered a collection of related cases:</p> <ol> <li>[\"GR\",\"109645\",\"2015-01-21\"]</li> <li>[\"GR\",\"109645\",\"1997-08-15\"]</li> <li>[\"GR\",\"109645\",\"1996-03-04\"]</li> <li>[\"GR\",\"109645\",\"1994-07-25\"]</li> </ol> <p>Typographic errors in these category and serial pairings, therefore, result in an unconnected case being considered a part of an ostensible collection. The following query is one way to check for an unconnected case being improperly included:</p> SQL<pre><code>select\n count(docket_date) num,\n docket_category,\n docket_serial,\n min(docket_date) earliest,\n max(docket_date) latest,\n max(docket_date) - min(docket_date) diff, -- large difference is indicative of impropriety in at least one category / serial pair\n json_group_array(docket_date) dates,\n json_group_array(origin) origins,\n json_group_array(title) titles\nfrom\n valid\nwhere\n docket_date is not null\ngroup by\n docket_category,\n docket_serial\nhaving\n num &gt;= 2\norder by\n diff desc, num desc\n</code></pre>"},{"location":"sqlite/#inconsistent-naming-convention-re-am-sc","title":"Inconsistent naming convention re: AM -SC","text":"<p>Originally thought that a suffixed <code>-SC</code> Administrative Matter meant that these were rule / statute patterns. After exploring the data, it appears that suffixed <code>-SC</code> AMs are also citation patterns for decisions, making it difficult to classify. To categorize the rules better, it may be useful to initially get the list of AMs as citation patterns and make statutory AMs an exclusive enumeration.</p> SQL<pre><code>select\n title, docket_category, docket_serial, docket_date\nfrom\n valid\nwhere\n docket_category = \"AM\"\n and docket_serial like '%-sc'\norder by docket_date desc\n</code></pre>"},{"location":"sqlite/#invalid-citation-patterns","title":"Invalid citation patterns","text":"SQL<pre><code>-- present GRs: 68 rows\nselect * from main.invalid where orig_idx like '%g r%' or orig_idx like '%g.r%' or orig_idx like '%gr%'\n\n-- admin matters: 50 rows\nselect * from main.invalid where orig_idx like '%a m%' or orig_idx like '%a.m%' or orig_idx like '%am%' or orig_idx like '%adm%m%'\n\n-- admin cases: 113 rows\nselect * from main.invalid where orig_idx like '%a c%' or orig_idx like '%a.c%' or orig_idx like '%ac%' or orig_idx like '%adm%c%'\n\n-- udks: 13 rows\nselect * from main.invalid where orig_idx like '%udk%'\n\n-- PET cases: 7 rows\nselect * from main.invalid where orig_idx like '%p.e.t%'\n\n-- too low char count: 65 rows\nselect * from main.invalid where length(orig_idx) &lt;= 7\n</code></pre>"},{"location":"sqlite/#impropriety-detector","title":"Impropriety detector","text":"SQL<pre><code>SELECT\n    COUNT(docket_date) num,\n    docket_category,\n    docket_serial,\n    MIN(docket_date) earliest,\n    MAX(docket_date) latest,\n    MAX(docket_date) - MIN(docket_date) diff,\n    -- large difference is indicative of impropriety in at least one category / serial pair\n    json_group_array(docket_date) dates,\n    json_group_array(origin) origins,\n    json_group_array(title) titles\nFROM\n    valid\nWHERE\n    docket_date IS NOT NULL\nGROUP BY\n    docket_category,\n    docket_serial\nHAVING\n    num &gt;= 2\nORDER BY\n    diff DESC,\n    num DESC\n</code></pre>"},{"location":"structure/","title":"API","text":""},{"location":"structure/#citabledocument","title":"CitableDocument","text":"<p>A <code>Citation</code>'s <code>extract_citations()</code> function relies on a <code>CitableDocument</code>.</p> <p>Creates three main reusable lists:</p> list concept <code>@docketed_reports</code> list of <code>DocketReportCitation</code> found in the text, excluding exceptional statutory dockets <code>@reports</code> list of <code>Report</code> found in the text (which may already be included in <code>@docketed_reports</code>) <code>@undocketed_reports</code> = <code>@docketed_reports</code> - <code>@reports</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text_statutes = \"Bar Matter No. 803, Jan. 1, 2000; Bar Matter No. 411, Feb. 1, 2000\"\n&gt;&gt;&gt; len(CitableDocument(text=text_statutes).docketed_reports) # no citations, since these are 'statutory dockets'\n0\n&gt;&gt;&gt; text_cites = \"374 Phil. 1, 10-11 (1999) 1111 SCRA 1111; G.R. No. 147033, April 30, 2003; G.R. No. 147033, April 30, 2003, 374 Phil. 1, 600; ABC v. XYZ, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449;  XXX, G.R. No. 31711, Sept. 30, 1971, 35 SCRA 190; Hello World, 1111 SCRA 1111; Y v. Z, 35 SCRA 190;\"\n&gt;&gt;&gt; doc1 = CitableDocument(text=text_cites)\n&gt;&gt;&gt; len(doc1.docketed_reports)\n4\n&gt;&gt;&gt; doc1.undocketed_reports\n{'1111 SCRA 1111'}\n&gt;&gt;&gt; text = \"&lt;em&gt;Gatchalian Promotions Talent Pool, Inc. v. Atty. Naldoza&lt;/em&gt;, 374 Phil. 1, 10-11 (1999), citing: &lt;em&gt;In re Almacen&lt;/em&gt;, 31 SCRA 562, 600 (1970).; People v. Umayam, G.R. No. 147033, April 30, 2003; &lt;i&gt;Bagong Alyansang Makabayan v. Zamora,&lt;/i&gt; G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449; Villegas &lt;em&gt;v.&lt;/em&gt; Subido, G.R. No. 31711, Sept. 30, 1971, 41 SCRA 190;\"\n&gt;&gt;&gt; doc2 = CitableDocument(text=text)\n&gt;&gt;&gt; set(doc2.get_citations()) == {'GR No. 147033, Apr. 30, 2003', 'GR No. 138570, Oct. 10, 2000, 342 SCRA 449', 'GR No. 31711, Sep. 30, 1971, 41 SCRA 190', '374 Phil. 1', '31 SCRA 562'}\nTrue\n</code></pre> Source code in <code>src/citation_utils/document.py</code> Python<pre><code>@dataclass\nclass CitableDocument:\n    \"\"\"Creates three main reusable lists:\n\n    list | concept\n    :--:|:--:\n    `@docketed_reports` | list of `DocketReportCitation` found in the text, excluding exceptional statutory dockets\n    `@reports` | list of `Report` found in the text (which may already be included in `@docketed_reports`)\n    `@undocketed_reports` | = `@docketed_reports` - `@reports`\n\n    Examples:\n        &gt;&gt;&gt; text_statutes = \"Bar Matter No. 803, Jan. 1, 2000; Bar Matter No. 411, Feb. 1, 2000\"\n        &gt;&gt;&gt; len(CitableDocument(text=text_statutes).docketed_reports) # no citations, since these are 'statutory dockets'\n        0\n        &gt;&gt;&gt; text_cites = \"374 Phil. 1, 10-11 (1999) 1111 SCRA 1111; G.R. No. 147033, April 30, 2003; G.R. No. 147033, April 30, 2003, 374 Phil. 1, 600; ABC v. XYZ, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449;  XXX, G.R. No. 31711, Sept. 30, 1971, 35 SCRA 190; Hello World, 1111 SCRA 1111; Y v. Z, 35 SCRA 190;\"\n        &gt;&gt;&gt; doc1 = CitableDocument(text=text_cites)\n        &gt;&gt;&gt; len(doc1.docketed_reports)\n        4\n        &gt;&gt;&gt; doc1.undocketed_reports\n        {'1111 SCRA 1111'}\n        &gt;&gt;&gt; text = \"&lt;em&gt;Gatchalian Promotions Talent Pool, Inc. v. Atty. Naldoza&lt;/em&gt;, 374 Phil. 1, 10-11 (1999), citing: &lt;em&gt;In re Almacen&lt;/em&gt;, 31 SCRA 562, 600 (1970).; People v. Umayam, G.R. No. 147033, April 30, 2003; &lt;i&gt;Bagong Alyansang Makabayan v. Zamora,&lt;/i&gt; G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449; Villegas &lt;em&gt;v.&lt;/em&gt; Subido, G.R. No. 31711, Sept. 30, 1971, 41 SCRA 190;\"\n        &gt;&gt;&gt; doc2 = CitableDocument(text=text)\n        &gt;&gt;&gt; set(doc2.get_citations()) == {'GR No. 147033, Apr. 30, 2003', 'GR No. 138570, Oct. 10, 2000, 342 SCRA 449', 'GR No. 31711, Sep. 30, 1971, 41 SCRA 190', '374 Phil. 1', '31 SCRA 562'}\n        True\n    \"\"\"  # noqa: E501\n\n    text: str\n\n    def __post_init__(self):\n        self.text = unicodedata.normalize(\"NFKD\", self.text)\n        self.reports = list(Report.extract_reports(self.text))\n        self.docketed_reports = list(self.get_docketed_reports(self.text))\n        self.undocketed_reports = self.get_undocketed_reports()\n\n    @classmethod\n    def get_docketed_reports(\n        cls, text: str, exclude_docket_rules: bool = True\n    ) -&gt; Iterator[DocketReport]:\n        \"\"\"Extract from `raw` text all raw citations which should include their `Docket` and `Report` component parts.\n        This may however include statutory rules since some docket categories like AM and BM use this convention.\n        To exclude statutory rules, a flag is included as a default.\n\n        Examples:\n            &gt;&gt;&gt; cite = next(CitableDocument.get_docketed_reports(\"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"))\n            &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n            {'publisher': 'SCRA', 'volume': '342', 'page': '449', 'context': 'G.R. Nos. 138570, 138572, 138587, 138680, 138698', 'category': 'GR', 'ids': '138570, 138572, 138587, 138680, 138698', 'docket_date': datetime.date(2000, 10, 10)}\n            &gt;&gt;&gt; statutory_text = \"Bar Matter No. 803, Jan. 1, 2000\"\n            &gt;&gt;&gt; next(CitableDocument.get_docketed_reports(statutory_text)) # default\n            Traceback (most recent call last):\n                ...\n            StopIteration\n\n        Args:\n            text (str): Text to look for `Dockets` and `Reports`\n\n        Yields:\n            Iterator[DocketReport]: Any of custom `Docket` with `Report` types, e.g. `CitationAC`, etc.\n        \"\"\"  # noqa: E501\n        text = unicodedata.normalize(\"NFKD\", text)\n        for search_func in (\n            CitationAC.search,\n            CitationAM.search,\n            CitationOCA.search,\n            CitationBM.search,\n            CitationGR.search,\n            CitationPET.search,\n            CitationUDK.search,\n            CitationJIB.search,\n        ):\n            # Each search function is applied to the text, each match yielded\n            for result in search_func(text):\n                if exclude_docket_rules:\n                    if is_statutory_rule(result):\n                        continue\n                    yield result\n\n    def get_undocketed_reports(self):\n        \"\"\"Steps:\n\n        1. From a set of `uniq_reports` (see `self.reports`);\n        2. Compare to reports found in `@docketed_reports`\n        3. Limit reports to those _without_ an accompaying docket\n        \"\"\"\n        uniq_reports = set(Report.get_unique(self.text))\n        for cite in self.docketed_reports:\n            if cite.volpubpage in uniq_reports:\n                uniq_reports.remove(cite.volpubpage)\n        return uniq_reports\n\n    def get_citations(self) -&gt; Iterator[str]:\n        \"\"\"There are two main lists to evaluate:\n\n        1. `@docketed_reports` - each includes a `Docket` (optionally attached to a `Report`)\n        2. `@reports` - from the same text, just get `Report` objects.\n\n        Can filter out `Report` objects not docketed and thus return\n        a more succinct citation list which includes both constructs mentioned above but\n        without duplicate `reports`.\n        \"\"\"  # noqa: E501\n        if self.docketed_reports:\n            for doc_report_cite in self.docketed_reports:\n                yield str(doc_report_cite)\n\n            if self.undocketed_reports:\n                yield from self.undocketed_reports  # already &lt;str&gt;\n        else:\n            if self.reports:\n                for report in self.reports:\n                    yield str(report)\n</code></pre>"},{"location":"structure/#citation_utils.CitableDocument-functions","title":"Functions","text":""},{"location":"structure/#citation_utils.CitableDocument.get_citations","title":"<code>get_citations()</code>","text":"<p>There are two main lists to evaluate:</p> <ol> <li><code>@docketed_reports</code> - each includes a <code>Docket</code> (optionally attached to a <code>Report</code>)</li> <li><code>@reports</code> - from the same text, just get <code>Report</code> objects.</li> </ol> <p>Can filter out <code>Report</code> objects not docketed and thus return a more succinct citation list which includes both constructs mentioned above but without duplicate <code>reports</code>.</p> Source code in <code>src/citation_utils/document.py</code> Python<pre><code>def get_citations(self) -&gt; Iterator[str]:\n    \"\"\"There are two main lists to evaluate:\n\n    1. `@docketed_reports` - each includes a `Docket` (optionally attached to a `Report`)\n    2. `@reports` - from the same text, just get `Report` objects.\n\n    Can filter out `Report` objects not docketed and thus return\n    a more succinct citation list which includes both constructs mentioned above but\n    without duplicate `reports`.\n    \"\"\"  # noqa: E501\n    if self.docketed_reports:\n        for doc_report_cite in self.docketed_reports:\n            yield str(doc_report_cite)\n\n        if self.undocketed_reports:\n            yield from self.undocketed_reports  # already &lt;str&gt;\n    else:\n        if self.reports:\n            for report in self.reports:\n                yield str(report)\n</code></pre>"},{"location":"structure/#citation_utils.CitableDocument.get_docketed_reports","title":"<code>get_docketed_reports(text, exclude_docket_rules=True)</code>  <code>classmethod</code>","text":"<p>Extract from <code>raw</code> text all raw citations which should include their <code>Docket</code> and <code>Report</code> component parts. This may however include statutory rules since some docket categories like AM and BM use this convention. To exclude statutory rules, a flag is included as a default.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; cite = next(CitableDocument.get_docketed_reports(\"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"))\n&gt;&gt;&gt; cite.model_dump(exclude_none=True)\n{'publisher': 'SCRA', 'volume': '342', 'page': '449', 'context': 'G.R. Nos. 138570, 138572, 138587, 138680, 138698', 'category': 'GR', 'ids': '138570, 138572, 138587, 138680, 138698', 'docket_date': datetime.date(2000, 10, 10)}\n&gt;&gt;&gt; statutory_text = \"Bar Matter No. 803, Jan. 1, 2000\"\n&gt;&gt;&gt; next(CitableDocument.get_docketed_reports(statutory_text)) # default\nTraceback (most recent call last):\n    ...\nStopIteration\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for <code>Dockets</code> and <code>Reports</code></p> required <p>Yields:</p> Type Description <code>DocketReport</code> <p>Iterator[DocketReport]: Any of custom <code>Docket</code> with <code>Report</code> types, e.g. <code>CitationAC</code>, etc.</p> Source code in <code>src/citation_utils/document.py</code> Python<pre><code>@classmethod\ndef get_docketed_reports(\n    cls, text: str, exclude_docket_rules: bool = True\n) -&gt; Iterator[DocketReport]:\n    \"\"\"Extract from `raw` text all raw citations which should include their `Docket` and `Report` component parts.\n    This may however include statutory rules since some docket categories like AM and BM use this convention.\n    To exclude statutory rules, a flag is included as a default.\n\n    Examples:\n        &gt;&gt;&gt; cite = next(CitableDocument.get_docketed_reports(\"Bagong Alyansang Makabayan v. Zamora, G.R. Nos. 138570, 138572, 138587, 138680, 138698, October 10, 2000, 342 SCRA 449\"))\n        &gt;&gt;&gt; cite.model_dump(exclude_none=True)\n        {'publisher': 'SCRA', 'volume': '342', 'page': '449', 'context': 'G.R. Nos. 138570, 138572, 138587, 138680, 138698', 'category': 'GR', 'ids': '138570, 138572, 138587, 138680, 138698', 'docket_date': datetime.date(2000, 10, 10)}\n        &gt;&gt;&gt; statutory_text = \"Bar Matter No. 803, Jan. 1, 2000\"\n        &gt;&gt;&gt; next(CitableDocument.get_docketed_reports(statutory_text)) # default\n        Traceback (most recent call last):\n            ...\n        StopIteration\n\n    Args:\n        text (str): Text to look for `Dockets` and `Reports`\n\n    Yields:\n        Iterator[DocketReport]: Any of custom `Docket` with `Report` types, e.g. `CitationAC`, etc.\n    \"\"\"  # noqa: E501\n    text = unicodedata.normalize(\"NFKD\", text)\n    for search_func in (\n        CitationAC.search,\n        CitationAM.search,\n        CitationOCA.search,\n        CitationBM.search,\n        CitationGR.search,\n        CitationPET.search,\n        CitationUDK.search,\n        CitationJIB.search,\n    ):\n        # Each search function is applied to the text, each match yielded\n        for result in search_func(text):\n            if exclude_docket_rules:\n                if is_statutory_rule(result):\n                    continue\n                yield result\n</code></pre>"},{"location":"structure/#citation_utils.CitableDocument.get_undocketed_reports","title":"<code>get_undocketed_reports()</code>","text":"<p>Steps:</p> <ol> <li>From a set of <code>uniq_reports</code> (see <code>self.reports</code>);</li> <li>Compare to reports found in <code>@docketed_reports</code></li> <li>Limit reports to those without an accompaying docket</li> </ol> Source code in <code>src/citation_utils/document.py</code> Python<pre><code>def get_undocketed_reports(self):\n    \"\"\"Steps:\n\n    1. From a set of `uniq_reports` (see `self.reports`);\n    2. Compare to reports found in `@docketed_reports`\n    3. Limit reports to those _without_ an accompaying docket\n    \"\"\"\n    uniq_reports = set(Report.get_unique(self.text))\n    for cite in self.docketed_reports:\n        if cite.volpubpage in uniq_reports:\n            uniq_reports.remove(cite.volpubpage)\n    return uniq_reports\n</code></pre>"},{"location":"structure/#docket-model","title":"Docket Model","text":"<p>               Bases: <code>BaseModel</code></p> <p>The <code>Docket</code> is the modern identifier of a Supreme Court decision. This data structure however is not the final form of the identifier since that description belongs to the <code>Citation</code> and the <code>CountedCitation</code>.</p> <p>The purpose of this intermediate structure is that a <code>Docket</code> is often paired with a <code>Report</code>, which is the traditional identifier based on volume and page numbers. The pairing however is not mandatory, thus needed flexibility to create structures with the following combinations of the eventual Citation object:</p> Citation Docket Report has both docket and report yes yes only a docket yes no only a report no yes <p>See docket_citation.DocketReportCitation to see structure of paired content.</p> <p>A <code>Docket</code> is based on a <code>category</code>, a <code>serial id</code>, and a <code>date</code>. Since the serial id may required</p> Field Type Description <code>context</code> optional (str) Full text matched by the regex pattern <code>category</code> optional (DocketCategory) Whether GR, AC, etc. <code>ids</code> optional (str) The serial number of the docket category <code>docket_date</code> optional (date) The date associated with the docket Sample Citation Category Serial Date G.R. Nos. 138570, October 10, 2000 GR 74910 October 10, 2000 A.M. RTJ-12-2317 (Formerly OCA I.P.I. No. 10-3378-RTJ), Jan 1, 2000 AM RTJ-12-2317 Jan 1, 2000 A.C. No. 10179 (Formerly CBD 11-2985), March 04, 2014 AC 10179 Mar. 4, 2014 Source code in <code>src/citation_utils/dockets/models/docket_model.py</code> Python<pre><code>class Docket(BaseModel):\n    \"\"\"\n    The `Docket` is the modern identifier of a Supreme Court decision. This data structure\n    however is not the final form of the identifier since that description belongs to the `Citation`\n    and the `CountedCitation`.\n\n    The purpose of this intermediate structure is that a `Docket` is often paired with a `Report`, which\n    is the traditional identifier based on volume and page numbers. The pairing however is not\n    mandatory, thus needed flexibility to create structures with the following combinations of\n    the eventual Citation object:\n\n    Citation | Docket | Report\n    :--:|:--:|:--:\n    has both docket and report | yes | yes\n    only a docket | yes | no\n    only a report | no | yes\n\n    See docket_citation.DocketReportCitation to see structure of paired content.\n\n    A `Docket` is based on a `category`, a `serial id`, and a `date`. Since the serial id\n    may required\n\n    Field | Type | Description\n    --:|:--:|:--\n    `context` | optional (str) | Full text matched by the regex pattern\n    `category` | optional (DocketCategory) | Whether GR, AC, etc.\n    `ids` | optional (str) | The serial number of the docket category\n    `docket_date` | optional (date) | The date associated with the docket\n\n    Sample Citation | Category | Serial | Date\n    :-- |:--:|:--:|:--:\n    _G.R. Nos. 138570, October 10, 2000_ | GR | 74910 | October 10, 2000\n    _A.M. RTJ-12-2317 (Formerly OCA I.P.I. No. 10-3378-RTJ), Jan 1, 2000_ | AM | RTJ-12-2317 |Jan 1, 2000\n    _A.C. No. 10179 (Formerly CBD 11-2985), March 04, 2014_ | AC | 10179 | Mar. 4, 2014\n    \"\"\"  # noqa: E501\n\n    context: str = Field(..., description=\"Full text matched by regex pattern.\")\n    category: DocketCategory = Field(..., description=\"e.g. General Register, etc.\")\n    ids: str = Field(\n        ..., description=\"This may be comma-separated, e.g. '12, 32, and 41'\"\n    )\n    docket_date: date = Field(...)\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Docket: {self.category} {self.serial_text}, {self.formatted_date}&gt;\"\n\n    def __str__(self) -&gt; str:\n        if self.serial_text:\n            return (\n                f\"{self.category} No. {self.serial_text.upper()}, {self.formatted_date}\"  # noqa: E501\n            )\n        return \"No proper string detected.\"\n\n    def __eq__(self, other: Self) -&gt; bool:\n        opt_1 = is_eq(self.category.name, other.category.name)\n        opt_2 = is_eq(self.first_id, other.first_id)\n        opt_3 = is_eq(self.docket_date.isoformat(), other.docket_date.isoformat())\n        return all([opt_1, opt_2, opt_3])\n\n    @property\n    def slug(self):\n        return \"-\".join(\n            [self.category.name, self.serial_text, self.docket_date.isoformat()]\n        )\n\n    @property\n    def serial_text(self) -&gt; str:\n        \"\"\"From raw `ids`, get the `cleaned_ids`, and of these `cleaned_ids`,\n            extract the `@first_id` found to deal with compound ids, e.g.\n            ids separated by 'and' and ','\n\n        Returns:\n            str: Singular text identifier\n        \"\"\"\n        if x := self.first_id or self.ids:\n            x = x.rstrip(\"*\u2022[]\")\n            if bits := x.split():\n                if len(bits) &gt; 1:\n                    if bits[0].isalpha() and not bits[1].startswith(\"-\"):\n                        x = f\"{bits[0]}-{bits[1]}\"\n                    elif bits[0].isalpha() and bits[1].startswith(\"-\"):  # mtj -02-1466\n                        x = f\"{bits[0]}{bits[1]}\"\n                    elif bits[1].isalpha() and not bits[0].endswith(\"-\"):\n                        x = f\"{bits[0]}-{bits[1]}\"\n                    elif bits[1].isalpha() and bits[0].endswith(\"-\"):  # '14061- ret'\n                        x = f\"{bits[0]}{bits[1]}\"\n            if adjust := gr_prefix_clean(x):\n                return adjust\n        return x.split()[0]\n\n    @property\n    def first_id(self) -&gt; str:\n        \"\"\"Get first bit from list of separated ids, when possible.\n\n        Returns:\n            str: First id found\n        \"\"\"\n\n        def first_exists(char: str, text: str):\n            \"\"\"If a `char` exists in the `text`, split on this value.\"\"\"\n            return text.split(char)[0] if char in text else None\n\n        for char in [\" - \", \"/\", \",\", \";\", \" and \", \" AND \", \"&amp;\"]:\n            if res := first_exists(char, self.ids):\n                return res\n        return self.ids\n\n    @property\n    def formatted_date(self) -&gt; str | None:\n        if self.docket_date:\n            return self.docket_date.strftime(DOCKET_DATE_FORMAT)\n        return None\n\n    @classmethod\n    def check_serial_num(cls, text: str) -&gt; bool:\n        \"\"\"If a serial number exists, ensure it meets criteria prior to row creation.\"\"\"\n        if DB_SERIAL_NUM.search(text.lower()):\n            return True\n        return False\n\n    @classmethod\n    def clean_serial(cls, text: str) -&gt; str | None:\n        \"\"\"Criteria:\n\n        1. Must be lowercased\n        2. Characters that can be included `a-z`, `0-9`, `-`\n        3. Must only contain a single alpha-numeric reference\n\n        Args:\n            text (str): Raw text to clean\n\n        Returns:\n            str: Cleaned serial text fit for database input.\n        \"\"\"\n        text = text.lower()\n        if \" \" in text:\n            text = text.split()[0]\n        if match := DB_SERIAL_NUM.search(text):\n            if candidate := match.group(\"serial\"):\n                return candidate\n        return None\n</code></pre>"},{"location":"structure/#citation_utils.dockets.Docket-attributes","title":"Attributes","text":""},{"location":"structure/#citation_utils.dockets.Docket.first_id","title":"<code>first_id: str</code>  <code>property</code>","text":"<p>Get first bit from list of separated ids, when possible.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>First id found</p>"},{"location":"structure/#citation_utils.dockets.Docket.serial_text","title":"<code>serial_text: str</code>  <code>property</code>","text":"<p>From raw <code>ids</code>, get the <code>cleaned_ids</code>, and of these <code>cleaned_ids</code>,     extract the <code>@first_id</code> found to deal with compound ids, e.g.     ids separated by 'and' and ','</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Singular text identifier</p>"},{"location":"structure/#citation_utils.dockets.Docket-functions","title":"Functions","text":""},{"location":"structure/#citation_utils.dockets.Docket.check_serial_num","title":"<code>check_serial_num(text)</code>  <code>classmethod</code>","text":"<p>If a serial number exists, ensure it meets criteria prior to row creation.</p> Source code in <code>src/citation_utils/dockets/models/docket_model.py</code> Python<pre><code>@classmethod\ndef check_serial_num(cls, text: str) -&gt; bool:\n    \"\"\"If a serial number exists, ensure it meets criteria prior to row creation.\"\"\"\n    if DB_SERIAL_NUM.search(text.lower()):\n        return True\n    return False\n</code></pre>"},{"location":"structure/#citation_utils.dockets.Docket.clean_serial","title":"<code>clean_serial(text)</code>  <code>classmethod</code>","text":"<p>Criteria:</p> <ol> <li>Must be lowercased</li> <li>Characters that can be included <code>a-z</code>, <code>0-9</code>, <code>-</code></li> <li>Must only contain a single alpha-numeric reference</li> </ol> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Raw text to clean</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>Cleaned serial text fit for database input.</p> Source code in <code>src/citation_utils/dockets/models/docket_model.py</code> Python<pre><code>@classmethod\ndef clean_serial(cls, text: str) -&gt; str | None:\n    \"\"\"Criteria:\n\n    1. Must be lowercased\n    2. Characters that can be included `a-z`, `0-9`, `-`\n    3. Must only contain a single alpha-numeric reference\n\n    Args:\n        text (str): Raw text to clean\n\n    Returns:\n        str: Cleaned serial text fit for database input.\n    \"\"\"\n    text = text.lower()\n    if \" \" in text:\n        text = text.split()[0]\n    if match := DB_SERIAL_NUM.search(text):\n        if candidate := match.group(\"serial\"):\n            return candidate\n    return None\n</code></pre>"},{"location":"structure/#docket-category","title":"Docket Category","text":""},{"location":"structure/#docket-category-model","title":"Docket Category Model","text":"<p>               Bases: <code>StrEnum</code></p> <p>Common docket references involving Philippine Supreme Court decisions.</p> Name Value <code>GR</code> General Register <code>AM</code> Administrative Matter <code>AC</code> Administrative Case <code>BM</code> Bar Matter <code>PET</code> Presidential Electoral Tribunal <code>OCA</code> Office of the Court Administrator <code>JIB</code> Judicial Integrity Board <code>UDK</code> Undocketed"},{"location":"structure/#citation_utils.dockets.DocketCategory--complications","title":"Complications","text":""},{"location":"structure/#citation_utils.dockets.DocketCategory--legacy-rules","title":"Legacy rules","text":"<p>These categories do not always represent decisions. For instance, there are are <code>AM</code> and <code>BM</code> docket numbers that represent rules rather than decisions.</p>"},{"location":"structure/#citation_utils.dockets.DocketCategory--redocketed-numbers","title":"Redocketed numbers","text":"<p>From the Supreme Court Stylebook (p. 159, 2024):</p> <p>11.3.1. Redocketed numbers</p> <p>Some cases may have an undocketed (UDK) number and may be redocketed and assigned a General Register (G.R.) number upon payment of the required docket fees. Still other cases may have a docket number starting with OCA IPI or JIB and may be redocketed as Administrative Matters (A.M.), while Commission on Bar Discipline (CBD) cases may be redocketed as Administrative Cases (A.C.). These must still be reflected in all court resolutions, orders, and decisions. x x x</p> Source code in <code>src/citation_utils/dockets/models/docket_category.py</code> Python<pre><code>class DocketCategory(StrEnum):\n    \"\"\"Common docket references involving Philippine Supreme Court decisions.\n\n    Name | Value\n    :--|:--\n    `GR` | General Register\n    `AM` | Administrative Matter\n    `AC` | Administrative Case\n    `BM` | Bar Matter\n    `PET` | Presidential Electoral Tribunal\n    `OCA` | Office of the Court Administrator\n    `JIB` | Judicial Integrity Board\n    `UDK` | Undocketed\n\n    ## Complications\n\n    ### Legacy rules\n\n    These categories do not always represent decisions. For instance,\n    there are are `AM` and `BM` docket numbers that represent rules rather\n    than decisions.\n\n    ### Redocketed numbers\n\n    From the Supreme Court Stylebook (p. 159, 2024):\n\n    &gt; 11.3.1. Redocketed numbers\n    &gt;\n    &gt; Some cases may have an undocketed (UDK) number and may be redocketed and assigned a\n    General Register (G.R.) number upon payment of the required docket fees. Still other cases may have\n    a docket number starting with OCA IPI or JIB and may be redocketed as Administrative Matters (A.M.),\n    while Commission on Bar Discipline (CBD) cases may be redocketed as Administrative Cases (A.C.).\n    These must still be reflected in all court resolutions, orders, and decisions. x x x\n    \"\"\"\n\n    GR = \"General Register\"\n    AM = \"Administrative Matter\"\n    AC = \"Administrative Case\"\n    BM = \"Bar Matter\"\n    PET = \"Presidential Electoral Tribunal\"\n    OCA = \"Office of the Court Administrator\"\n    JIB = \"Judicial Integrity Board\"\n    UDK = \"Undocketed\"\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Uses name of member `gr` instead of Enum default\n        `&lt;DocketCategory.GR: 'General Register'&gt;`. It becomes to\n        use the following conventions:\n\n        Examples:\n            &gt;&gt;&gt; DocketCategory['GR']\n            'GR'\n            &gt;&gt;&gt; DocketCategory.GR\n            'GR'\n\n        Returns:\n            str: The value of the Enum name\n        \"\"\"\n        return str.__repr__(self.name.upper())\n</code></pre>"},{"location":"structure/#citation_utils.dockets.DocketCategory-functions","title":"Functions","text":""},{"location":"structure/#citation_utils.dockets.DocketCategory.__repr__","title":"<code>__repr__()</code>","text":"<p>Uses name of member <code>gr</code> instead of Enum default <code>&lt;DocketCategory.GR: 'General Register'&gt;</code>. It becomes to use the following conventions:</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; DocketCategory['GR']\n'GR'\n&gt;&gt;&gt; DocketCategory.GR\n'GR'\n</code></pre> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The value of the Enum name</p> Source code in <code>src/citation_utils/dockets/models/docket_category.py</code> Python<pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Uses name of member `gr` instead of Enum default\n    `&lt;DocketCategory.GR: 'General Register'&gt;`. It becomes to\n    use the following conventions:\n\n    Examples:\n        &gt;&gt;&gt; DocketCategory['GR']\n        'GR'\n        &gt;&gt;&gt; DocketCategory.GR\n        'GR'\n\n    Returns:\n        str: The value of the Enum name\n    \"\"\"\n    return str.__repr__(self.name.upper())\n</code></pre>"},{"location":"structure/#docket-citationconstructor","title":"Docket CitationConstructor","text":"<p>Although the different category docket models share a similar configuration, the regex strings involved are different for each, prompting the need for a preparatory constructor class:</p> <p>               Bases: <code>BaseModel</code></p> <p>Prefatorily, regex strings are defined so that a <code>re.Pattern</code> object can take advantage of the \"group_name\" assigned in the string.</p> <p>These are the docket styles with regex strings predefined:</p> <ol> <li>General Register</li> <li>Administrative Matter</li> <li>Administrative Case</li> <li>Bar Matter</li> <li>Office of the Court Administrator</li> <li>Presidential Electoral Tribunal</li> <li>Judicial Integrity Board</li> <li>Undocketed Case</li> </ol> <p>The CitationConstructor formalizes the assigned group names into their respective fields.</p> <p>Relatedly, it takes advantage of the <code>citation_date</code> and the <code>citation_report</code> libraries in generating the main <code>@pattern</code> since the regex strings above are only concerned with the <code>key</code> <code>num</code> <code>id</code> formula part of the docket, e.g. <code>GR</code> <code>No.</code> <code>123</code>... but not the accompanying date and report.</p> Source code in <code>src/citation_utils/dockets/models/constructor.py</code> Python<pre><code>class CitationConstructor(BaseModel):\n    \"\"\"Prefatorily, regex strings are defined so that a\n    `re.Pattern` object can take advantage of the \"group_name\"\n    assigned in the string.\n\n    These are the docket styles with regex strings predefined:\n\n    1. General Register\n    2. Administrative Matter\n    3. Administrative Case\n    4. Bar Matter\n    5. Office of the Court Administrator\n    6. Presidential Electoral Tribunal\n    7. Judicial Integrity Board\n    8. Undocketed Case\n\n    The CitationConstructor formalizes the assigned group names into\n    their respective fields.\n\n    Relatedly, it takes advantage of\n    the `citation_date` and the `citation_report` libraries in\n    generating the main `@pattern` since the regex strings above\n    are only concerned with the `key` `num` `id` formula part\n    of the docket, e.g. `GR` `No.` `123`... but not the accompanying\n    date and report.\n    \"\"\"\n\n    label: str = Field(\n        ...,\n        title=\"Docket Label\",\n        description=\"e.g. General Register, Administrative Matter\",\n    )\n    short_category: str = Field(\n        ..., title=\"Docket Category Shorthand\", description=\"e.g. GR, AM\"\n    )\n    group_name: str = Field(\n        ...,\n        title=\"Regex Group Name\",\n        description=(\n            \"e.g. 'gr_test_phrase' identifies that portion of the\"\n            \"Match object that should be associated with the label.\"\n        ),\n    )\n    init_name: str = Field(\n        ...,\n        title=\"Regex Initial Group Name\",\n        description=\"e.g. gr_mid, am_init; see .regexes for other group names\",\n    )\n    docket_regex: str = Field(\n        ...,\n        title=\"Regex Expression Proper\",\n        description=(\n            \"The full regex expression which includes the groupnames referred to above.\"\n        ),\n    )\n    key_regex: str = Field(\n        ...,\n        title=\"Regex Key\",\n        description=\"Regex portion to get the serial ids\",\n    )\n    num_regex: str = Field(\n        ...,\n        title=\"Regex Num\",\n        description=\"Regex portion for the num keyword to get the serial ids\",\n    )\n\n    @property\n    def pattern(self) -&gt; re.Pattern:\n        \"\"\"Construct the regex string and generate a full Pattern object from:\n\n        1. `docket_regex`,\n        2. `docket_date` defined in the citation-date library\n        3. an optional `REPORT_REGEX` defined in the citation-report library\n\n        Returns:\n            Pattern: Combination of Docket and Report styles.\n        \"\"\"\n        return re.compile(\n            \"\".join(\n                [\n                    rf\"{self.docket_regex}\",\n                    rf\"(?P&lt;extra_phrase&gt;{formerly}?{pp}?){DOCKET_DATE_REGEX}\",\n                    rf\"(?P&lt;opt_report&gt;\\,\\s*{REPORT_REGEX})?\",\n                ]\n            ),\n            re.I | re.X,\n        )\n\n    @property\n    def key_num_pattern(self) -&gt; re.Pattern:\n        \"\"\"Unlike full @pattern, this regex compiled object is limited to\n        just the key and number elements, e.g. \"GR No. 123\" or \"BP Blg. 45\"\n        \"\"\"\n        regex = rf\"{self.key_regex}({self.num_regex})?\"\n        return re.compile(regex, re.I | re.X)\n\n    def detect(self, raw: str) -&gt; Iterator[dict[str, Any]]:\n        \"\"\"Logic: if `self.init_name` Match group exists, get entire\n        regex based on `self.group_name`, extract subgroups which will\n        consist of `Docket` and `Report` parts.\n\n        Args:\n            raw (str): Text to evaluate\n\n        Yields:\n            Iterator[dict[str, Any]]: A dict that can fill up a Docket + Report pydantic BaseModel\n        \"\"\"  # noqa: E501\n        for match in self.pattern.finditer(raw):\n            if match.group(self.init_name):\n                if ctx := match.group(self.group_name).strip(\", \"):\n                    raw_id = cull_extra(self.key_num_pattern.sub(\"\", ctx))\n                    ids = raw_id.strip(\"()[] .,;\")\n                    raw_date = match.group(\"docket_date\")\n                    date_found = decode_date(raw_date, True)\n                    if ids and date_found:\n                        yield dict(\n                            context=ctx,\n                            short_category=self.short_category,\n                            category=self.label,\n                            ids=ids,\n                            docket_date=date_found,\n                            publisher=get_publisher_label(match),\n                            volpubpage=match.group(\"volpubpage\"),\n                            volume=match.group(\"volume\"),\n                            page=match.group(\"page\"),\n                        )\n</code></pre>"},{"location":"structure/#citation_utils.dockets.models.CitationConstructor-attributes","title":"Attributes","text":""},{"location":"structure/#citation_utils.dockets.models.CitationConstructor.key_num_pattern","title":"<code>key_num_pattern: re.Pattern</code>  <code>property</code>","text":"<p>Unlike full @pattern, this regex compiled object is limited to just the key and number elements, e.g. \"GR No. 123\" or \"BP Blg. 45\"</p>"},{"location":"structure/#citation_utils.dockets.models.CitationConstructor.pattern","title":"<code>pattern: re.Pattern</code>  <code>property</code>","text":"<p>Construct the regex string and generate a full Pattern object from:</p> <ol> <li><code>docket_regex</code>,</li> <li><code>docket_date</code> defined in the citation-date library</li> <li>an optional <code>REPORT_REGEX</code> defined in the citation-report library</li> </ol> <p>Returns:</p> Name Type Description <code>Pattern</code> <code>Pattern</code> <p>Combination of Docket and Report styles.</p>"},{"location":"structure/#citation_utils.dockets.models.CitationConstructor-functions","title":"Functions","text":""},{"location":"structure/#citation_utils.dockets.models.CitationConstructor.detect","title":"<code>detect(raw)</code>","text":"<p>Logic: if <code>self.init_name</code> Match group exists, get entire regex based on <code>self.group_name</code>, extract subgroups which will consist of <code>Docket</code> and <code>Report</code> parts.</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>str</code> <p>Text to evaluate</p> required <p>Yields:</p> Type Description <code>dict[str, Any]</code> <p>Iterator[dict[str, Any]]: A dict that can fill up a Docket + Report pydantic BaseModel</p> Source code in <code>src/citation_utils/dockets/models/constructor.py</code> Python<pre><code>def detect(self, raw: str) -&gt; Iterator[dict[str, Any]]:\n    \"\"\"Logic: if `self.init_name` Match group exists, get entire\n    regex based on `self.group_name`, extract subgroups which will\n    consist of `Docket` and `Report` parts.\n\n    Args:\n        raw (str): Text to evaluate\n\n    Yields:\n        Iterator[dict[str, Any]]: A dict that can fill up a Docket + Report pydantic BaseModel\n    \"\"\"  # noqa: E501\n    for match in self.pattern.finditer(raw):\n        if match.group(self.init_name):\n            if ctx := match.group(self.group_name).strip(\", \"):\n                raw_id = cull_extra(self.key_num_pattern.sub(\"\", ctx))\n                ids = raw_id.strip(\"()[] .,;\")\n                raw_date = match.group(\"docket_date\")\n                date_found = decode_date(raw_date, True)\n                if ids and date_found:\n                    yield dict(\n                        context=ctx,\n                        short_category=self.short_category,\n                        category=self.label,\n                        ids=ids,\n                        docket_date=date_found,\n                        publisher=get_publisher_label(match),\n                        volpubpage=match.group(\"volpubpage\"),\n                        volume=match.group(\"volume\"),\n                        page=match.group(\"page\"),\n                    )\n</code></pre>"}]}